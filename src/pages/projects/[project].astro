---
import { CldImage } from "astro-cloudinary";
import data from "../../data/projects/index";
import type { ProjectData } from "../../types/project";
import Layout from "../../layouts/Layout.astro";
import Header from "../../components/Header.astro";
import Footer from "../../components/Footer.astro";
import "../../styles/portfolio.css";

export function getStaticPaths() {
  return data.map((item) => ({
    params: { project: item.project },
  }));
}

const { project } = Astro.params;

const projectData = data.find((item) => item.project === project) as ProjectData;

// Create dynamic styleframe set based on project data
const styleframeSet = projectData?.styleframes?.map((item) => item.src) || [];
---

<Layout>
  <div class="page-container scroll-container">
    <!-- Header Navigation -->
    <Header />

    <!-- Hero Section -->
    <main class="hero-section snap-section">
      <div class="hero-content-wrapper">
        <div class="hero-content" id="hero-card">
          <!-- Project Title & Description -->
          <div class="hero-desc">
            <div class="hero-text">
              <h1 class="hero-title">
                <div set:html={projectData?.title} />
              </h1>
              <p class="hero-description">
                {projectData?.description1}
              </p>
            </div>

            <!-- Thumbnail Carousel -->
            <div class="carousel-container">
              <div class="carousel-wrapper" id="hero-carousel" data-slider>
                {
                  (projectData?.styleframes || []).map((item, index) => (
                    <div class="carousel-item">
                      <div
                        class="carousel-item-inner"
                        data-image-url={styleframeSet[index]}
                        data-image-index={index}
                      >
                        <CldImage
                          class="carousel-image2"
                          src={item.src}
                          alt="Styleframe ${index}"
                        />
                        <span class="carousel-number">STY-{index + 1}</span>
                      </div>
                    </div>
                  ))
                }
              </div>
            </div>
          </div>

          <!-- Project Metadata -->
          <div class="project-metadata">
            <div class="metadata-item">
              <span class="metadata-label">YEAR</span>
              <span class="metadata-value">2023</span>
            </div>
            <div class="metadata-item">
              <span class="metadata-label">ROLE</span>
              <span class="metadata-value"
                >Creative Direction, Motion Design</span
              >
            </div>
            <div class="metadata-item">
              <span class="metadata-label">TOOLS</span>
              <span class="metadata-value"
                >Figma, Adobe AE, PR & Illustrator</span
              >
            </div>
            <div class="metadata-item">
              <span class="metadata-label">TYPE</span>
              <span class="metadata-value">Launch Teaser</span>
            </div>
          </div>
        </div>
      </div>
    </main>

    <!-- VIDEO SECTION -->
    <section class="snap-section video-section">
      <div class="video-embed-wrapper">
        <iframe
          src="https://player.vimeo.com/video/809298150?badge=0&autopause=0&player_id=0&app_id=58479&autoplay=0&loop=1&title=0&byline=0&portrait=0&transparent=0"
          frameborder="0"
          allow="autoplay; fullscreen; picture-in-picture; clipboard-write; encrypted-media; web-share"
          referrerpolicy="strict-origin-when-cross-origin"
          style="position:absolute;top:0;left:0;width:100%;height:100%;"
          title="Faramove Launch"
          allowfullscreen></iframe>
      </div>
    </section>
    <script src="https://player.vimeo.com/api/player.js"></script>

    <script>
      // Hide Vimeo side dock elements
      function hideVimeoSideDock() {
        const iframe = document.querySelector(
          ".video-embed-wrapper iframe"
        ) as HTMLIFrameElement;
        if (iframe) {
          iframe.addEventListener("load", () => {
            try {
              const iframeDoc =
                iframe.contentDocument || iframe.contentWindow?.document;
              if (iframeDoc) {
                // Create and inject CSS to hide side dock elements
                const style = iframeDoc.createElement("style");
                style.textContent = `
								.SideDock_module_sidedockInner__eeb5e08f,
								[class*="SideDock_module_sidedockInner"],
								[class*="sidedockInner"] {
									display: none !important;
									visibility: hidden !important;
									opacity: 0 !important;
								}
							`;
                iframeDoc.head.appendChild(style);
              }
            } catch (e) {
              // Cross-origin restrictions - use overlay instead
              console.log("Using CSS overlay to hide side dock elements");
            }
          });
        }
      }

      // Run when DOM is ready
      document.addEventListener("DOMContentLoaded", hideVimeoSideDock);
    </script>

    <!-- VIDEO MODAL -->
    <div id="video-modal" class="video-modal">
      <div class="video-modal-content">
        <!-- Close Button -->
        <button id="modal-close" class="modal-close" aria-label="Close modal">
          <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M6 18L18 6M6 6l12 12"></path>
          </svg>
        </button>

        <!-- Modal Video Player -->
        <video
          id="modal-video-player"
          class="modal-video-player"
          controls
          autoplay
        >
          <source id="modal-video-source" src="" type="video/mp4" />
          Your browser does not support the video tag.
        </video>
      </div>
    </div>
  </div>

  <!-- PROCESS BREAKDOWN SECTION -->
  <section class="process-section design-process-breakdown">
    <div class="process-container">
      <!-- Header -->
      <div class="process-header">
        <h2
          class="process-title"
          set:html={projectData?.["design-process-title"] || "Add Title"}
        />
        <div class="process-description">
          <p
            set:html={projectData?.["design-process-par"] || "Add process description"}
          />
        </div>
      </div>

      <!-- Decorative Lines with Image Containers -->
      <div class="decorative-lines">
        <svg
          class="grid-lines-svg"
          preserveAspectRatio="none"
          viewBox="0 0 1512 400"
          xmlns="http://www.w3.org/2000/svg"
        >
          <!-- Lines will be generated by JavaScript -->
        </svg>

        <!-- Image Container Overlay -->
        <div class="sketch-container-wrapper">
          <div class="sketch-container-grid">
            <!-- Row 1: Main Sketch Containers -->
            <div
              class="sketch-container main-sketch"
              data-grid-column="1"
              data-grid-row="1"
            >
              <CldImage
                src={projectData?.["design-process-images"]?.[0]?.src || ""}
                alt={projectData?.["design-process-images"]?.[0]?.alt || "Main sketch"}
                class="sketch-image"
              />
            </div>

            <div
              class="sketch-container mobile-sketch-1"
              data-grid-column="2"
              data-grid-row="1"
            >
              <CldImage
                src={projectData?.["design-process-images"]?.[1]?.src || ""}
                alt={projectData?.["design-process-images"]?.[1]?.alt || "Mobile sketch 1"}
                class="sketch-image"
              />
            </div>

            <div
              class="sketch-container mobile-sketch-2"
              data-grid-column="3"
              data-grid-row="1"
            >
              <CldImage
                src={projectData?.["design-process-images"]?.[2]?.src || ""}
                alt={projectData?.["design-process-images"]?.[2]?.alt || "Mobile sketch 2"}
                class="sketch-image"
              />
            </div>

            <!-- Row 2: Text Blocks - Equal Width -->
            <div class="sketch-container text-block-1">
              <div class="text-content">
                <p
                  set:html={projectData?.["design-text-block-1"] ||
                    "Add text block 1 content"}
                />
              </div>
            </div>

            <div class="sketch-container text-block-2">
              <!-- Text content will go here -->
              <div class="text-content">
                <p
                  set:html={projectData?.["design-text-block-2"] ||
                    "Add text block 2 content"}
                />
              </div>
            </div>

            <!-- Row 3: Full Width Text Block -->
            <div class="sketch-container text-block-full">
              <!-- Challenge Section -->
              <div class="challenge-section">
                <div class="challenge-badge">
                  <p class="challenge-label">challenge</p>
                  <p class="challenge-number">ONE</p>
                </div>
                <h2
                  class="challenge-title"
                  set:html={projectData?.["design-challenge-title"] ||
                    "Add challenge title"}
                />
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- STYLEFRAMES DETAIL SECTION -->
  <section class="styleframes-section">
    <div class="styleframes-container">
      <div class="styleframes-content">
        <!-- Large Preview with Counter -->
        <div
          class="styleframes-preview"
          data-styleframes={JSON.stringify(styleframeSet)}
        >
          <img
            id="current-styleframe"
            src={styleframeSet[0]}
            alt="Current styleframe"
            class="preview-image"
          />
          <div class="styleframe-counter">
            <div class="counter-number current">1</div>
            <span class="counter-of">OF</span>
            <div class="counter-number total">
              {(projectData?.styleframes || []).length}
            </div>
          </div>
        </div>

        <!-- bottom rail: masked horizontal rail (placeholders for now) -->
        <div class="carousel-container styleframes-carousel">
          <!-- Fixed detection rectangle on far left -->
          <div class="fixed-detection-rect" id="styleframe-detector"></div>
          <div class="carousel-wrapper" id="hero-carousel" data-slider>
            {
              (projectData?.styleframes || []).map((item, index) => (
                <div class="carousel-item">
                  <div
                    class="carousel-item-inner"
                    data-image-url={styleframeSet[index]}
                    data-image-index={index}
                  >
                    <CldImage
                      class="carousel-image2"
                      src={item.src}
                      alt="Styleframe ${index}"
                    />
                  </div>
                </div>
              ))
            }
          </div>
        </div>
      </div>
    </div>

    <!-- Styleframes Breakdown Section -->
    <div class="styleframes-breakdown">
      <!-- Top: Flex with images (left) and text (right) -->
      <div class="breakdown-top">
        <div class="breakdown-images">
          <img
            src="/png/Faramove-APMF-Style-Frame_B&W.png"
            alt="Faramove APMF Style Frame B&W"
            class="breakdown-image"
          />
          <img
            src="/GIF/Farmove-pointer-select.gif"
            alt="Faramove pointer select animation"
            class="breakdown-image"
          />
          <img
            src="/png/Faramove-Truck-UI-Style-Frame.png"
            alt="Faramove Truck UI Style Frame"
            class="breakdown-image"
          />
        </div>
        <div class="breakdown-text">
          <h2 class="breakdown-title">{projectData?.["styleframes-breakdown"]?.["top-text"]?.title}</h2>
          <div class="breakdown-content">
            {
              projectData?.["styleframes-breakdown"]?.["top-text"]?.content?.map((paragraph, index) => (
                <p class="breakdown-paragraph">{paragraph}</p>
              ))
            }
          </div>
        </div>
      </div>
      
      <!-- Bottom: 2-column grid layout -->
      <!-- Bottom: Flex Column Layout -->
      <div class="breakdown-layout">
        <!-- Row 1: Two images (Matched Height) -->
        <div class="breakdown-row-top">
          <div class="breakdown-item-large">
            <img src="/png/Road_Ariel_STYL-F_Blue.png" alt="Faramove logo" class="breakdown-media" />
          </div>
          <div class="breakdown-item-tall">
            <img src="/png/aerial-view-road-intersection-roundabout.png" alt="Aerial road view" class="breakdown-media breakdown-media-2" />
          </div>
        </div>
        
        <!-- Row 2: One full-width image -->
        <div class="breakdown-item-full">
          <!-- Placeholder for full-width media -->
        </div>
        
        <!-- Row 3: Two equal side-by-side images -->
        <div class="breakdown-row-bottom">
          <div class="breakdown-item-half">
            <img src="/png/Faramove-AAMF-SF-unused-2.png" alt="Faramove unused style frame 1" class="breakdown-media" />
          </div>
          <div class="breakdown-item-half">
            <img src="/png/Faramove-pointer-SF-unused.png" alt="Faramove unused style frame 2" class="breakdown-media" />
          </div>
        </div>
      </div>
    </div>
  </section>
</Layout>

<!-- CHALLENGE SECTION -->
<section class="process-section motion-process-section">
  <div class="process-container">
    <!-- Header -->
    <div class="process-header">
      <h2 class="process-title">{projectData?.["motion-process-title"]}</h2>
      <div class="process-description">
        <p set:html={projectData?.["motion-process-par"] || "Add motion process description"} />
      </div>
    </div>

    <!-- Decorative Lines with Image Containers -->
    <div class="decorative-lines">
      <svg
        class="grid-lines-svg"
        preserveAspectRatio="none"
        viewBox="0 0 1512 400"
        xmlns="http://www.w3.org/2000/svg"
      >
        <!-- Lines will be generated by JavaScript -->
      </svg>

      <!-- Image Container Overlay -->
      <div class="sketch-container-wrapper">
        <div class="sketch-container-grid motion-variant">
          <!-- Row 1: Process Image Containers -->
          <div
            class="sketch-container motion-side-1"
            data-grid-column="1"
            data-grid-row="1"
          >
             <img
               src="/png/faramove-box-unwrapped.png"
               alt="Faramove box unwrapped"
                  class="sketch-image"
                />
          </div>

          <div
            class="sketch-container motion-side-2"
            data-grid-column="1"
            data-grid-row="2"
          >
             <img
               src="/GIF/farmove-box-spin-loop.gif"
               alt="Faramove box spin animation"
                  class="sketch-image"
                />
          </div>

          <div
            class="sketch-container motion-main"
            data-grid-column="2"
            data-grid-row="1"
          >
             <img
               src="/GIF/farmove-pointer-parcel-pickup-loop.gif"
               alt="Faramove parcel pickup animation"
                  class="sketch-image"
                />
          </div>

          <!-- Row 2: Text Blocks - Equal Width -->
          <div class="sketch-container text-block-1">
                <div class="text-content">
              <p
                set:html={projectData?.["motion-text-block-1"] || "Add motion text 1"}
              />
                </div>
              </div>

          <div class="sketch-container text-block-2">
            <div class="text-content">
              <p
                set:html={projectData?.["motion-text-block-2"] || "Add motion text 2"}
              />
            </div>
          </div>

          <!-- Row 3: Full Width Text Block -->
          <div class="sketch-container text-block-full">
            <!-- Challenge Section -->
            <div class="challenge-section">
              <div class="challenge-badge">
                <p class="challenge-label">challenge</p>
                <p class="challenge-number">TWO</p>
              </div>
              <h2 class="challenge-title">the rigs.</h2>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Full-width GIF Banner -->
    <div class="motion-divider-banner"></div>

    <div class="decorative-lines">
      <svg
        class="grid-lines-svg"
        preserveAspectRatio="none"
        viewBox="0 0 1512 400"
        xmlns="http://www.w3.org/2000/svg"
      >
        <!-- Lines will be generated by JavaScript -->
      </svg>

      <!-- Image Container Overlay -->
      <div class="sketch-container-wrapper">
        <div class="sketch-container-grid motion-variant">
          <!-- Row 1: Process Image Containers -->
          <div
            class="sketch-container motion-side-1"
            data-grid-column="1"
            data-grid-row="1"
          >
             <img
               src="/png/Faramove-cc-bend-it-ss.png"
               alt="Faramove CC Bend It effect"
               class="sketch-image"
             />
  </div>

          <div
            class="sketch-container motion-side-2"
            data-grid-column="1"
            data-grid-row="2"
          >
             <img
               src="/GIF/farmove-arrow-loop-wide.gif"
               alt="Faramove arrow loop animation"
               class="sketch-image"
             />
            </div>

          <div
            class="sketch-container motion-main"
            data-grid-column="2"
            data-grid-row="1"
          >
             <img
               src="/GIF/farmove-pointer-ariel-loop.gif"
               alt="Faramove pointer animation"
               class="sketch-image"
             />
        </div>
        
          <!-- Row 2: Text Blocks - Equal Width -->
          <div class="sketch-container text-block-1">
            <div class="text-content">
              <p
                set:html={projectData?.["motion-text-block-3"] || "Add motion text 3"}
              />
            </div>
        </div>

          <div class="sketch-container text-block-2">
            <div class="text-content">
              <p
                set:html={projectData?.["motion-text-block-4"] || "Add motion text 4"}
              />
            </div>
          </div>
        </div>
      </div>
    </div>
    </div>
</section>

<!-- SPEED LINES SECTION -->
<section class="sound-design-section">
  <div class="sound-design-container">
    <!-- Top: Full Width Image -->
    <div class="sound-design-top">
      <img src="/png/Faramove-Music_PP-Audio-Stacks.png" alt="Faramove Audio Stacks" />
          </div>
    
    <!-- Bottom: Split Layout -->
    <div class="sound-design-bottom">
      <!-- Left: Image + Caption -->
      <div class="sound-bottom-left">
        <div class="sound-channel-image">
          <img src="/png/Faramove-Tom&Hat_PP-Audio-Channel.png" alt="Faramove Audio Channel" />
        </div>
        <p class="sound-caption">
          {projectData?.["sound-design"]?.["audio-caption"] || "Tom_and_Snare_Fill-Mastered.wav"}
        </p>
        </div>
      
      <!-- Right: Text Content -->
      <div class="sound-bottom-right">
        <h2 class="sound-title">{projectData?.["sound-design"]?.title || "noises"}</h2>
        <p class="sound-description">
          {projectData?.["sound-design"]?.description || "When you decide to open a teaser with the brand logo sitting on screen for 5 seconds, you need something extra to keep viewers from hitting the skip button: sound. Staying true to my “DO NOTs” and avoiding any heavy UI cues, I pushed this idea through the audio. I chose a sound that felt deliberately unexpected—using a tom and snare to open an app video where clicks, bells, notifications, and swooshes are what you’d normally expect."}
        </p>
      </div>
    </div>
  </div>
</section>

<!-- CREDITS SECTION -->
<section class="credits-section">
  <div class="credits-container">
    <div class="credits-list">
      {projectData?.credits?.map((credit) => (
        <div class="credit-item">
          <p class="credit-role">{credit.role}</p>
          <p class="credit-name">{credit.name}</p>
        </div>
      ))}
    </div>
    
    <div class="credits-header">
      <h2 class="credits-title">credits</h2>
      <p class="credits-subtitle">priviledged to work with some of the most talented people existing.</p>
      
      <div class="more-cc-link">
        <a href="#" class="cc-link-text">more cc</a>
        <div class="cc-arrow">
          <svg width="12" height="10" viewBox="0 0 12 10" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M1 5L11 5M11 5L7 1M11 5L7 9" stroke="#7d8484" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </div>
      </div>
    </div>
  </div>
</section>

<Footer />

<script>
  // @ts-check
  import Smooothy from "smooothy";
  import { gsap } from "gsap";
  import { ScrollTrigger } from "gsap/ScrollTrigger";

  // Register GSAP plugins
  gsap.registerPlugin(ScrollTrigger);

  // Navigation active state management
  const navLinks = document.querySelectorAll(".nav a");
  const headerLogo = document.querySelector(".header-logo") as HTMLElement;
  const allNavElements = [...navLinks, headerLogo];

  // Initial active state is handled by Header component based on route
  // Click handlers below manage interactive state changes

  navLinks.forEach((link) => {
    link.addEventListener("click", () => {
      // Remove active class from all nav elements
      allNavElements.forEach((element) => {
        if (element) element.classList.remove("active");
      });
      // Add active class to clicked link
      link.classList.add("active");
      // Update URL to show the clicked link's href
      const href = link.getAttribute("href");
      if (href) {
        window.history.pushState(null, "", href);
      }
    });
  });

  // Add click handler for header logo
  if (headerLogo) {
    headerLogo.addEventListener("click", (e) => {
      e.preventDefault(); // Prevent default anchor behavior
      // Remove active class from all nav elements
      allNavElements.forEach((element) => {
        if (element) element.classList.remove("active");
      });
      // Add active class to header logo
      headerLogo.classList.add("active");
      // Update URL to show home route
      window.history.pushState(null, "", "#");
      // Scroll to top of page
      window.scrollTo({ top: 0, behavior: "smooth" });
    });
  }

  // GSAP Parallax Effect - Hero Content Wrapper
  const heroContentWrapper = document.querySelector(".hero-content-wrapper");
  const videoSection = document.querySelector(".video-section");
  const scrollContainer = document.querySelector(".scroll-container");

  if (heroContentWrapper && videoSection) {
    // Ease-out for fast start, slow end when scrolling back
    const easeOut = "power2.out"; // Fast start, slow end - perfect for scroll back

    // Calculate distance based on viewport height (since hero is 80vh)
    // Move it by 100vh to ensure it's completely out of view
    const moveDistance = -(window.innerHeight * 0.15); // Move by full viewport height

    console.log("Hero move distance:", moveDistance, "vh");

    // Move up animation with ease-out and depth effect - responsive when scrolling back
    gsap.to(heroContentWrapper, {
      y: moveDistance,
      scale: 0.85, // Slight scale down for depth as it moves away
      ease: easeOut,
      scrollTrigger: {
        trigger: ".video-section",
        start: "top bottom-=300", // Start even earlier (200px before main sketch)
        end: "center center", // End when center of process section hits center of viewport (halfway through)
        scrub: 0.2, // Faster response for quicker return when scrolling back
        markers: false,
      },
    });

    // Enhanced fade out with custom ease
    gsap.to(heroContentWrapper, {
      opacity: 0,
      ease: "power3.out", // More dramatic ease curve
      scrollTrigger: {
        trigger: ".hero-section",
        start: "center top", // Starts later - when center of hero hits top
        end: () => `+=${(videoSection as HTMLElement).offsetTop}`, // Match the movement end
        scrub: 0, // Slightly slower for smoother fade
        markers: false,
      },
    });
  }

  // GSAP Snap Scrolling for Video Section
  if (scrollContainer && videoSection) {
    // Use ScrollTrigger.scrollerProxy for custom scroll container
    ScrollTrigger.scrollerProxy(scrollContainer, {
      scrollTop(value?: number) {
        if (arguments.length && value !== undefined) {
          scrollContainer.scrollTop = value;
        }
        return scrollContainer.scrollTop;
      },
      getBoundingClientRect() {
        return {
          top: 0,
          left: 0,
          width: window.innerWidth,
          height: window.innerHeight,
        };
      },
    });

    // Create snap point at video section
    ScrollTrigger.create({
      trigger: ".video-section",
      scroller: scrollContainer,
      start: "top 60%",
      end: "top 40%",
      onEnter: () => {
        gsap.to(scrollContainer, {
          scrollTop: (videoSection as HTMLElement).offsetTop,
          duration: 0.8,
          ease: "power2.inOut",
          overwrite: true,
        });
      },
      onEnterBack: () => {
        gsap.to(scrollContainer, {
          scrollTop:
            (videoSection as HTMLElement).offsetTop - window.innerHeight,
          duration: 0.8,
          ease: "power2.inOut",
          overwrite: true,
        });
      },
      markers: false,
    });

    // Refresh ScrollTrigger after setup
    ScrollTrigger.refresh();
  }


  // Process sections parallax animations - loop through all sections
  const processSections = document.querySelectorAll(".process-section");

  processSections.forEach((section) => {
    // Main Sketch parallax animation
    const mainSketch = section.querySelector(".main-sketch");

    if (mainSketch) {
      gsap.from(mainSketch, {
        y: -350, // Move down 350px as you scroll
        scrollTrigger: {
          trigger: section, // Trigger when this specific process section enters viewport
          start: "top bottom", // Start when top of process section hits bottom of viewport
          end: "center center", // End when center of process section hits center of viewport (halfway through)
          scrub: 1, // Smooth parallax effect tied to scroll
          markers: false,
        },
      });
    }

    // Mobile Sketch containers - reverse movement with offset
    const mobileSketch1 = section.querySelector(".mobile-sketch-1");
    const mobileSketch2 = section.querySelector(".mobile-sketch-2");

    if (mobileSketch1) {
      gsap.from(mobileSketch1, {
        y: 350, // Start below and move up (reverse of main sketch)
        scrollTrigger: {
          trigger: section, // Trigger when this specific process section enters viewport
          start: "top bottom-=100", // Start earlier (100px before main sketch)
          end: "center center", // End when center of process section hits center of viewport (halfway through)
          scrub: 1, // Smooth parallax effect tied to scroll
          markers: false,
        },
      });
    }

    if (mobileSketch2) {
      gsap.from(mobileSketch2, {
        y: 350, // Start below and move up (reverse of main sketch)
        scrollTrigger: {
          trigger: section, // Trigger when this specific process section enters viewport
          start: "top bottom-=500", // Start even earlier (200px before main sketch)
          end: "center center", // End when center of process section hits center of viewport (halfway through)
          scrub: 1, // Smooth parallax effect tied to scroll
          markers: false,
        },
      });
    }
  });

  // Initialize Swiper Hero Carousel
  const heroCarousel = document.getElementById("hero-carousel") as HTMLElement;

  // Gallery Modal Functionality
  const modal = document.getElementById("video-modal");
  const modalVideo = document.getElementById(
    "modal-video-player"
  ) as HTMLVideoElement;
  const modalVideoSource = document.getElementById(
    "modal-video-source"
  ) as HTMLSourceElement;
  const modalClose = document.getElementById("modal-close");
  const galleryItems = document.querySelectorAll(".gallery-item");

  // Open modal with video
  function openModal(videoUrl: string) {
    if (modal && modalVideo && modalVideoSource) {
      modalVideoSource.src = videoUrl;
      modalVideo.load();
      modal.classList.add("active");
      document.body.style.overflow = "hidden"; // Prevent background scrolling
    }
  }

  // Close modal
  function closeModal() {
    if (modal && modalVideo) {
      modal.classList.remove("active");
      modalVideo.pause();
      modalVideo.currentTime = 0;
      document.body.style.overflow = ""; // Re-enable scrolling
    }
  }

  // Add click handlers to gallery items
  galleryItems.forEach((item) => {
    item.addEventListener("click", () => {
      const videoUrl = item.getAttribute("data-video");
      if (videoUrl) {
        openModal(videoUrl);
      }
    });
  });

  // Close modal on close button click
  modalClose?.addEventListener("click", closeModal);

  // Close modal on outside click
  modal?.addEventListener("click", (e) => {
    if (e.target === modal) {
      closeModal();
    }
  });

  // Close modal on Escape key
  document.addEventListener("keydown", (e) => {
    if (e.key === "Escape" && modal?.classList.contains("active")) {
      closeModal();
    }
  });

  // Pause marquee on hover
  const marqueeContent = document.querySelector(
    ".marquee-content"
  ) as HTMLElement;
  const marqueeContainer = document.querySelector(".marquee-container");

  marqueeContainer?.addEventListener("mouseenter", () => {
    if (marqueeContent) {
      marqueeContent.style.animationPlayState = "paused";
    }
  });

  marqueeContainer?.addEventListener("mouseleave", () => {
    if (marqueeContent) {
      marqueeContent.style.animationPlayState = "running";
    }
  });

  // SVG Grid Lines Generator
  function generateGridLines() {
    const svgs = document.querySelectorAll(
      ".grid-lines-svg"
    ) as NodeListOf<SVGElement>;
    if (!svgs || svgs.length === 0) return;

    // Generate lines for each SVG element
    svgs.forEach((svg) => {
      const container = svg.parentElement;
      if (!container) return;

      // Configuration
      const config = {
        lineSpacing: 22, // Spacing between lines in pixels
        topSegmentStart: 0.24, // 333.508 / 1395 ≈ 0.24
        topSegmentEnd: 0.434, // 605.368 / 1395 ≈ 0.434
        middleSegmentEnd: 0.706, // 985.368 / 1395 ≈ 0.706
        bottomSegmentEnd: 0.901, // 1257.23 / 1395 ≈ 0.901
        thickStrokeWidth: 9,
        thinStrokeWidth: 1,
        strokeColor: "#ACAAA3",
        startOffset: 5, // Minimal offset to prevent cut-off
      };

      // Clear existing lines
      svg.innerHTML = "";

      // Calculate container width and number of lines
      const containerWidth = container.offsetWidth;

      // Use full container width for viewBox
      svg.setAttribute("viewBox", `0 0 ${containerWidth} 400`);

      // Calculate available width for lines (account for left/right padding of overlay grid)
      let horizontalPadding = 0;
      const overlayGridForPadding = container.querySelector(
        ".sketch-container-grid"
      ) as HTMLElement | null;
      if (overlayGridForPadding) {
        const cs2 = getComputedStyle(overlayGridForPadding);
        const padLeft = parseFloat(cs2.paddingLeft || "0");
        const padRight = parseFloat(cs2.paddingRight || "0");
        horizontalPadding = padLeft + padRight;
      }
      const availableWidth =
        containerWidth - horizontalPadding - config.startOffset * 2;

      // Keep constant spacing but distribute leftover equally on both sides
      const spacing = config.lineSpacing;
      const numLines = Math.floor(availableWidth / spacing) + 1; // number of lines so last index fits in width
      const spanWidth = (numLines - 1) * spacing; // distance from first to last line
      const sideRemainder = Math.max(availableWidth - spanWidth, 0);
      const sidePadding = sideRemainder / 2; // equal gap on left and right inside overlay padding

      // Start position: left overlay padding + inner offset + equalized side padding
      const leftOverlayPadding = overlayGridForPadding
        ? parseFloat(getComputedStyle(overlayGridForPadding).paddingLeft || "0")
        : 0;
      const adjustedStartOffset =
        leftOverlayPadding + config.startOffset + sidePadding;

      // Get the actual SVG height from viewBox or container
      const svgHeight = (svg as any).viewBox.baseVal.height || 400;

      // Read top/bottom padding from the overlay grid so thick segments can form a border
      let topPaddingPx = 0;
      let bottomPaddingPx = 0;
      const overlayGrid = container.querySelector(
        ".sketch-container-grid"
      ) as HTMLElement | null;
      if (overlayGrid) {
        const cs = getComputedStyle(overlayGrid);
        topPaddingPx = parseFloat(cs.paddingTop || "0");
        bottomPaddingPx = parseFloat(cs.paddingBottom || "0");
      }

      // Generate lines
      for (let i = 0; i < numLines; i++) {
        const x = adjustedStartOffset + i * spacing;
        const groupIndex = Math.floor(i / 5); // Group every 5 lines for future animation

        // Create group for this line (for future animation control)
        const group = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "g"
        );
        group.classList.add("grid-line-group");
        group.setAttribute("data-group", groupIndex.toString());
        group.setAttribute("data-line", i.toString());

        // Top segment (thick stroke) - from very top to the start of the middle (acts like border)
        const topLine = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "path"
        );
        topLine.setAttribute("d", `M${x} ${topPaddingPx}V0`);
        topLine.setAttribute("stroke", config.strokeColor);
        topLine.setAttribute(
          "stroke-width",
          config.thickStrokeWidth.toString()
        );
        topLine.classList.add("grid-line-top");
        group.appendChild(topLine);

        // Middle segment (thin stroke) - spans the grid area between paddings
        const middleLine = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "path"
        );
        middleLine.setAttribute(
          "d",
          `M${x} ${topPaddingPx}V${svgHeight - bottomPaddingPx}`
        );
        middleLine.setAttribute("stroke", config.strokeColor);
        middleLine.setAttribute(
          "stroke-width",
          config.thinStrokeWidth.toString()
        );
        middleLine.classList.add("grid-line-middle");
        group.appendChild(middleLine);

        // Bottom segment (thick stroke) - from end of middle to very bottom (acts like border)
        const bottomLine = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "path"
        );
        bottomLine.setAttribute(
          "d",
          `M${x} ${svgHeight}V${svgHeight - bottomPaddingPx}`
        );
        bottomLine.setAttribute("stroke", config.strokeColor);
        bottomLine.setAttribute(
          "stroke-width",
          config.thickStrokeWidth.toString()
        );
        bottomLine.classList.add("grid-line-bottom");
        group.appendChild(bottomLine);

        svg.appendChild(group);
      }
    }); // End forEach loop for each SVG
  }

  // Update SVG height based on container grid height
  function updateSVGHeight() {
    const processSections = document.querySelectorAll(".process-section");

    processSections.forEach((section) => {
      const svg = section.querySelector(".grid-lines-svg") as SVGElement;
      const containerWrapper = section.querySelector(
        ".sketch-container-wrapper"
      ) as HTMLElement;
      const decorativeLines = section.querySelector(
        ".decorative-lines"
      ) as HTMLElement;

      if (!svg || !containerWrapper || !decorativeLines) return;

      // Get the actual height of the container wrapper
      const gridHeight = containerWrapper.offsetHeight;

      // Update decorative-lines container height
      decorativeLines.style.height = `${gridHeight}px`;

      // Get current viewBox
      const viewBox = svg.getAttribute("viewBox");
      if (!viewBox) return;

      const [x, y, width] = viewBox.split(" ").map(Number);

      // Update viewBox height to match grid height
      svg.setAttribute("viewBox", `${x} ${y} ${width} ${gridHeight}`);
    });

    // Regenerate lines with new height for all sections
    generateGridLines();
  }

  // Call after grid generation and on resize
  window.addEventListener("DOMContentLoaded", () => {
    setTimeout(() => {
      generateGridLines();
      updateSVGHeight();
    }, 100);
  });

  // Also try to initialize immediately if DOM is already loaded
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", () => {
      setTimeout(() => {
        generateGridLines();
        updateSVGHeight();
      }, 100);
    });
  } else {
    setTimeout(() => {
      generateGridLines();
      updateSVGHeight();
    }, 100);
  }

  // Update on resize
  let resizeTimeout: ReturnType<typeof setTimeout>;
  window.addEventListener("resize", () => {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
      updateSVGHeight();
      // Force Smooothy to recalculate viewport on resize with 1512px constraint
      if (typeof heroCarouselInstance !== "undefined") {
        heroCarouselInstance.resize();
        // Force viewport constraint after resize
        if (
          heroCarouselInstance.viewport &&
          heroCarouselInstance.viewport.wrapperWidth > 1512
        ) {
          heroCarouselInstance.viewport.wrapperWidth = 1512;
        }
      }
      if (typeof thumbsCarousel !== "undefined") {
        thumbsCarousel.resize();
        // Force viewport constraint after resize
        if (
          thumbsCarousel.viewport &&
          thumbsCarousel.viewport.wrapperWidth > 1512
        ) {
          console.log("Styleframes carousel - forcing viewport to 1512px");
          thumbsCarousel.viewport.wrapperWidth = 1512;
        }
      }
    }, 250);
  });

  // ==================== HERO CAROUSEL WITH SMOOOTHY ====================
  const heroCarouselElement = document.getElementById(
    "hero-carousel"
  ) as HTMLElement;
  let heroCarouselInstance: any;

  if (heroCarouselElement) {
    console.log("Hero carousel found:", heroCarouselElement);

    // Initialize Smooothy for hero carousel
    heroCarouselInstance = new Smooothy(heroCarouselElement, {
      infinite: true,
      snap: false,
      dragSensitivity: 0.019,
      lerpFactor: 0.35,
      scrollInput: true,
      onUpdate: (instance) => {
        // Force viewport to think we're on a 1512px screen
        if (instance.viewport && instance.viewport.wrapperWidth > 1512) {
          instance.viewport.wrapperWidth = 1512;
        }
      },
    });

    // Auto-scroll functionality for hero carousel
    let heroAutoScrollSpeed = -0.003; // Slower speed for hero carousel
    let heroIsPaused = false;

    // Pause on hover for hero carousel
    heroCarouselElement.addEventListener("mouseenter", () => {
      heroIsPaused = true;
    });

    heroCarouselElement.addEventListener("mouseleave", () => {
      heroIsPaused = false;
    });

    // Animation loop for hero carousel auto-scroll using GSAP ticker
    function updateHero() {
      if (!heroIsPaused) {
        heroCarouselInstance.target += heroAutoScrollSpeed;
      }
    }

    // Use GSAP ticker for smooth updates
    gsap.ticker.add(updateHero);
    gsap.ticker.add(heroCarouselInstance.update.bind(heroCarouselInstance));
  } else {
    console.error("Hero carousel not found in DOM");
  }

  // ==================== STYLEFRAMES THUMBS WITH SMOOOTHY ====================
  // Find the second carousel (styleframes thumbs) - it's the second .carousel-wrapper
  const carouselWrappers = document.querySelectorAll(".carousel-wrapper");
  const thumbsRail = carouselWrappers[1] as HTMLElement; // Second carousel is the thumbs rail
  let thumbsCarousel: any;

  console.log("Total carousel wrappers found:", carouselWrappers.length);
  console.log("First carousel (hero):", carouselWrappers[0]);
  console.log("Second carousel (thumbs):", carouselWrappers[1]);

  // Get styleframeSet from data attribute
  const previewContainer = document.querySelector(
    ".styleframes-preview"
  ) as HTMLElement;
  const styleframeSet = previewContainer
    ? JSON.parse(previewContainer.getAttribute("data-styleframes") || "[]")
    : [];

  if (thumbsRail) {
    console.log("Thumbs rail found:", thumbsRail);

    // Initialize Smooothy for thumbs rail - DRAG ONLY, NO AUTO-SCROLL
    thumbsCarousel = new Smooothy(thumbsRail, {
      infinite: false, // No infinite loop - this naturally prevents over-scrolling
      snap: true, // Enable snapping for smooth drag-to-stop behavior
      dragSensitivity: 0.019, // Same drag sensitivity as hero
      lerpFactor: 0.35, // Same lerp factor as hero
      scrollInput: true,
      onUpdate: (instance) => {
        // Force viewport to think we're on a 1512px screen
        if (instance.viewport && instance.viewport.wrapperWidth > 1512) {
          console.log("Forcing viewport to 1512px");
          instance.viewport.wrapperWidth = 1512;
        }
        // Let Smooothy handle bounds naturally with infinite: false
      },
    });

    // NO auto-scroll functionality - drag only
    // But we still need GSAP ticker for drag animations
    gsap.ticker.add(thumbsCarousel.update.bind(thumbsCarousel));
    console.log("Styleframes carousel initialized - drag only, no auto-scroll");

    // ==================== DYNAMIC PREVIEW IMAGE SYSTEM ====================
    // Get all carousel items and preview image
    const carouselItems = thumbsRail.querySelectorAll(".carousel-item-inner");
    const previewImage = document.getElementById(
      "current-styleframe"
    ) as HTMLImageElement;
    const detector = document.getElementById("styleframe-detector");
    const counterNumber = document.querySelector(
      ".counter-number.current"
    ) as HTMLElement;

    function updatePreviewImage() {
      if (!detector || !previewImage) return;

      const detectorRect = detector.getBoundingClientRect();
      const detectorLeft = detectorRect.left;
      const detectorRight = detectorRect.right;

      carouselItems.forEach((item, index) => {
        const rect = item.getBoundingClientRect();
        const centerX = (rect.left + rect.right) / 2;

        // Check if item center intersects with detector
        if (centerX >= detectorLeft && centerX <= detectorRight) {
          // Get the image from this carousel item
          const carouselImage = item.querySelector(
            ".carousel-image2"
          ) as HTMLImageElement;
          if (carouselImage && carouselImage.src) {
            (previewImage as HTMLImageElement).src = carouselImage.src;
            (previewImage as HTMLImageElement).alt =
              carouselImage.alt || "Current Styleframe";

            // Update the counter to show current item number (1-based)
            if (counterNumber) {
              counterNumber.textContent = (index + 1).toString();
            }

            console.log(
              "Preview updated with:",
              carouselImage.src,
              "Counter:",
              index + 1
            );
          }
        }
      });
    }

    // Update on scroll/drag
    gsap.ticker.add(updatePreviewImage);

    // Initial update
    updatePreviewImage();
  } else {
    console.error("Thumbs rail (second carousel) not found in DOM");
  }

  // ==================== MOTION DIVIDER BANNER LOGIC ====================
  function initMotionDivider() {
    const banner = document.querySelector(".motion-divider-banner") as HTMLElement;
    if (!banner) return;

    // Helper to populate banner
    const populateBanner = () => {
      // Clear existing content
      banner.innerHTML = "";
      
      // We need to know the aspect ratio of the image to calculate how many we need
      // Create a temporary image to load and check dimensions
      const tempImg = new Image();
      tempImg.src = "/GIF/farmove-arrow-loop.gif";
      
      tempImg.onload = () => {
        const imgWidth = tempImg.naturalWidth;
        const imgHeight = tempImg.naturalHeight;
        
        // Calculate effective width after rotation (-90deg)
        // When rotated -90deg:
        // The visual width of the item becomes its original height
        // The visual height of the item becomes its original width
        
        // However, we want the items to fit the container height (150px)
        // Container Height = 150px
        // So the Rotated Item Height (Visual Height) must be 150px.
        // Visual Height = Original Width.
        // So we need to scale the image such that Original Width = 150px.
        
        const targetHeight = 90; // Reduced height for smaller items
        const scaleRatio = targetHeight / imgWidth;
        
        // Scaled Original Height = imgHeight * scaleRatio
        // Visual Width = Scaled Original Height
        const itemVisualWidth = imgHeight * scaleRatio;
        
        // Calculate how many items needed to fill screen width
        const screenWidth = window.innerWidth;
        const count = Math.ceil(screenWidth / itemVisualWidth) + 1; // Add buffer
        
        // Create images
        const fragment = document.createDocumentFragment();
        for (let i = 0; i < count; i++) {
          // Create a wrapper div to handle layout space for rotated element
          const wrapper = document.createElement("div");
          wrapper.style.width = `${itemVisualWidth}px`;
          wrapper.style.height = `${targetHeight}px`;
          wrapper.style.display = "flex";
          wrapper.style.alignItems = "center";
          wrapper.style.justifyContent = "center";
          wrapper.style.overflow = "hidden"; // clip any overflow
          
          const img = document.createElement("img");
          img.src = "/GIF/farmove-arrow-loop.gif";
          img.alt = "Motion divider";
          img.className = "motion-banner-item";
          
          // Force image dimensions to match the scale required
          // We want Original Width to be 150px (to match container height when rotated)
          // But wait, if we rotate -90, height becomes width.
          // CSS transform rotates the element but doesn't change layout flow unless we handle it.
          // The .motion-banner-item class has transform: rotate(-90deg)
          
          // If we set width: 150px on the img tag (which becomes height visually), 
          // and height: auto (which becomes width visually).
          img.style.width = `${targetHeight}px`; 
          img.style.height = "auto";
          
          // We need to ensure the rotated image is centered in the wrapper
          // wrapper is itemVisualWidth x 150
          
          wrapper.appendChild(img);
          fragment.appendChild(wrapper);
        }
        
        banner.appendChild(fragment);
      };
    };

    populateBanner();
    
    // Re-populate on resize (debounce)
    let resizeTimeout: ReturnType<typeof setTimeout>;
    window.addEventListener("resize", () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(populateBanner, 250);
    });
  }

  // Initialize motion divider
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initMotionDivider);
  } else {
    initMotionDivider();
  }
</script>

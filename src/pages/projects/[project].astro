---
import { CldImage } from "astro-cloudinary";
import data from "../../assets/data.json";
import Layout from "../../layouts/Layout.astro";
import Header from "../../components/Header.astro";
import "../../styles/portfolio.css";

export function getStaticPaths() {
    return data.map((item) => ({
    params: { project: item.project },
    }));
  }
  
  const { project } = Astro.params;

  const projectData = data.find((item) => item.project === project);

// Create dynamic styleframe set based on project data
const styleframeSet = projectData?.styleframes?.map((item) => item.src) || [];
---

<Layout>
	<div class="page-container scroll-container">
		<!-- Header Navigation -->
    <Header />

		<!-- Hero Section -->
		<main class="hero-section snap-section">
			<div class="hero-content-wrapper">
				<div class="hero-content" id="hero-card">
						<!-- Project Title & Description -->
						<div class="hero-desc">
							<div class="hero-text">
								<h1 class="hero-title">
                <div set:html={projectData?.title} />
								</h1>
								<p class="hero-description">
									{projectData?.description1}
								</p>
							</div>

							<!-- Thumbnail Carousel -->
            <div class="carousel-container">
              <div class="carousel-wrapper" id="hero-carousel" data-slider>
							{
                  (projectData?.styleframes || []).map((item, index) => (
							<div class="carousel-item">
										<div
											class="carousel-item-inner"
                        data-image-url={styleframeSet[index]}
											data-image-index={index}
										>
                                            <CldImage
                                            class="carousel-image2"
  src={item.src}
  alt="Styleframe ${index}"
/>
                        <span class="carousel-number">STY-{index + 1}</span>
								</div>
							</div>
								))
							}
							</div>
							</div>
						</div>

						<!-- Project Metadata -->
						<div class="project-metadata">
							<div class="metadata-item">
								<span class="metadata-label">YEAR</span>
								<span class="metadata-value">2023</span>
							</div>
							<div class="metadata-item">
								<span class="metadata-label">ROLE</span>
								<span class="metadata-value"
								>Creative Direction, Motion Design</span
								>
							</div>
							<div class="metadata-item">
								<span class="metadata-label">TOOLS</span>
								<span class="metadata-value"
								>Figma, Adobe AE, PR & Illustrator</span
								>
							</div>
							<div class="metadata-item">
								<span class="metadata-label">TYPE</span>
							<span class="metadata-value">Launch Teaser</span>
							</div>
						</div>
				</div>
			</div>
		</main>

		<!-- VIDEO SECTION -->
		<section class="snap-section video-section">
			<div class="video-embed-wrapper">
				<iframe
          src="https://player.vimeo.com/video/809298150?badge=0&autopause=0&player_id=0&app_id=58479&autoplay=0&loop=1&title=0&byline=0&portrait=0&transparent=0"
					frameborder="0" 
					allow="autoplay; fullscreen; picture-in-picture; clipboard-write; encrypted-media; web-share" 
					referrerpolicy="strict-origin-when-cross-origin" 
					style="position:absolute;top:0;left:0;width:100%;height:100%;" 
					title="Faramove Launch"
          allowfullscreen></iframe>
			</div>
	</section>
		<script src="https://player.vimeo.com/api/player.js"></script>

	<script>
		// Hide Vimeo side dock elements
		function hideVimeoSideDock() {
        const iframe = document.querySelector(
          ".video-embed-wrapper iframe"
        ) as HTMLIFrameElement;
			if (iframe) {
          iframe.addEventListener("load", () => {
					try {
              const iframeDoc =
                iframe.contentDocument || iframe.contentWindow?.document;
						if (iframeDoc) {
							// Create and inject CSS to hide side dock elements
                const style = iframeDoc.createElement("style");
							style.textContent = `
								.SideDock_module_sidedockInner__eeb5e08f,
								[class*="SideDock_module_sidedockInner"],
								[class*="sidedockInner"] {
									display: none !important;
									visibility: hidden !important;
									opacity: 0 !important;
								}
							`;
							iframeDoc.head.appendChild(style);
						}
					} catch (e) {
						// Cross-origin restrictions - use overlay instead
              console.log("Using CSS overlay to hide side dock elements");
					}
				});
			}
		}

		// Run when DOM is ready
      document.addEventListener("DOMContentLoaded", hideVimeoSideDock);
	</script>
	
		  <!-- VIDEO MODAL -->
		  <div id="video-modal" class="video-modal">
			<div class="video-modal-content">
			  <!-- Close Button -->
        <button id="modal-close" class="modal-close" aria-label="Close modal">
				<svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
						<path
							stroke-linecap="round"
							stroke-linejoin="round"
							stroke-width="2"
							d="M6 18L18 6M6 6l12 12"></path>
				</svg>
			  </button>
	  
			  <!-- Modal Video Player -->
			  <video
				id="modal-video-player"
				class="modal-video-player"
				controls
				autoplay
			  >
				<source id="modal-video-source" src="" type="video/mp4" />
				Your browser does not support the video tag.
			  </video>
				</div>
			</div>
		</div>

	<!-- PROCESS SECTION -->
  <section class="process-section design-process-section">
		<div class="process-container">
			<!-- Header -->
			<div class="process-header">
        <h2
          class="process-title"
          set:html={projectData?.["process-title"] || "Add Title"}
        />
				<div class="process-description">
          <p
            set:html={projectData?.["process-par"] || "Add process description"}
          />
				</div>
			</div>

			<!-- Decorative Lines with Image Containers -->
			<div class="decorative-lines">
				<svg
					class="grid-lines-svg"
					preserveAspectRatio="none"
					viewBox="0 0 1512 400"
					xmlns="http://www.w3.org/2000/svg"
				>
					<!-- Lines will be generated by JavaScript -->
				</svg>

				<!-- Image Container Overlay -->
				<div class="sketch-container-wrapper">
					<div class="sketch-container-grid">
						<!-- Row 1: Main Sketch Containers -->
						<div
							class="sketch-container main-sketch"
							data-grid-column="1"
							data-grid-row="1"
						>
              <CldImage
                src={projectData?.sketches?.[0]?.src || ""}
                alt={projectData?.sketches?.[0]?.alt || "Main sketch"}
                class="sketch-image"
              />
						</div>

						<div
							class="sketch-container mobile-sketch-1"
							data-grid-column="2"
							data-grid-row="1"
						>
              <CldImage
                src={projectData?.sketches?.[1]?.src || ""}
                alt={projectData?.sketches?.[1]?.alt || "Mobile sketch 1"}
                class="sketch-image"
              />
						</div>

						<div
							class="sketch-container mobile-sketch-2"
							data-grid-column="3"
							data-grid-row="1"
						>
              <CldImage
                src={projectData?.sketches?.[2]?.src || ""}
                alt={projectData?.sketches?.[2]?.alt || "Mobile sketch 2"}
                class="sketch-image"
              />
						</div>

						<!-- Row 2: Text Blocks - Equal Width -->
						<div class="sketch-container text-block-1">
							<div class="text-content">
                <p
                  set:html={projectData?.["text-block-1-par"] ||
                    "Add text block 1 content"}
                />
							</div>
						</div>

						<div class="sketch-container text-block-2">
							<!-- Text content will go here -->
              <div class="text-content">
                <p
                  set:html={projectData?.["text-block-2-par"] ||
                    "Add text block 2 content"}
                />
              </div>
						</div>

						<!-- Row 3: Full Width Text Block -->
						<div class="sketch-container text-block-full">
							<!-- Challenge Section -->
							<div class="challenge-section">
								<div class="challenge-badge">
									<p class="challenge-label">challenge</p>
									<p class="challenge-number">ONE</p>
								</div>
                <h2
                  class="challenge-title"
                  set:html={projectData?.["challenge-title"] ||
                    "Add challenge title"}
                />
							</div>
						</div>
					</div>
				</div>
			</div>
		</div>
	</section>

	<!-- STYLEFRAMES DETAIL SECTION -->
	<section class="styleframes-section">
		<div class="styleframes-container">
			<div class="styleframes-content">
				<!-- Large Preview with Counter -->
        <div
          class="styleframes-preview"
          data-styleframes={JSON.stringify(styleframeSet)}
        >
                    <img
                        id="current-styleframe"
                        src={styleframeSet[0]}
						alt="Current styleframe"
						class="preview-image"
					/>
					<div class="styleframe-counter">
						<div class="counter-number current">1</div>
						<span class="counter-of">OF</span>
                        <div class="counter-number total">
              {(projectData?.styleframes || []).length}
                        </div>
					</div>
				</div>

        <!-- bottom rail: masked horizontal rail (placeholders for now) -->
        <div class="carousel-container styleframes-carousel">
            <!-- Fixed detection rectangle on far left -->
            <div class="fixed-detection-rect" id="styleframe-detector"></div>
            <div class="carousel-wrapper" id="hero-carousel" data-slider>
              {
                (projectData?.styleframes || []).map((item, index) => (
                  <div class="carousel-item">
                    <div
                      class="carousel-item-inner"
                      data-image-url={styleframeSet[index]}
                      data-image-index={index}
                    >
                      <CldImage
                        class="carousel-image2"
                        src={item.src}
                        alt="Styleframe ${index}"
                      />
                    </div>
                  </div>
                ))
              }
            </div>
				</div>
			</div>
			</div>

			<!-- Synced reveal stage + Text Blocks -->
			<div class="styleframes-sync">
				<div class="left-stack">
					<h2 class="styleframes-title">Design.</h2>
					<div class="reveal-stage">
						<div class="preview-slot" data-slot="1">1</div>
						<div class="preview-slot" data-slot="2">2</div>
						<div class="preview-slot" data-slot="3">3</div>
					</div>
				</div>
				
				<!-- Right: Scrolling text blocks -->
				 <div class="styleframes-text-wrapper">
					<div class="styleframes-text">
						<div class="text-block" data-section="0">
							<h3>make a u-turn</h3>
							<p>
              This project only had the 4-major features of the app as the
              script, meant for me to work with. The first assumption was
              thinking what needed to be done was showing off the mobile app
              interfaces but then this is a teaser. This wouldn't be the first
              of its kind to come into the market. It needed a second or two of
              "Please do not skip me."
							</p>
						</div>
						<div class="text-block" data-section="1">
							<h3>pique interest</h3>
							<p>
              Shortly before this project, I had worked on a looping loader
              animation for the mobile app. The idea came to me to reuse the
              looping motion as the opener and look for a way to make the first
              3 seconds remarkable. Since the logo already looked nice, I needed
              to only do some more transformations for the rest of the video to
              pick up from. This would make the dump the idea of showing off the
              interfaces and depend solely on graphic elements to tell the
              story.
							</p>
						</div>
						<div class="text-block" data-section="2">
							<h3>pixellated noise</h3>
							<p>
              The flow for the rest of the video came naturally. I wanted a way
              to represent speed but without using motion blurs. The fast moving
              lines from 00:33secs combines random wiggle expressions and
              glitches simply by applying a wiggle expression on the trim path
              and gap property of a stroke.
							</p>
						</div>
					</div>
				 </div>
			</div>
	</section>
</Layout>

	<!-- CHALLENGE SECTION -->
<section class="process-section motion-process-section">
		<div class="process-container">
			<!-- Header -->
			<div class="process-header">
				<h2 class="process-title">2D but make it look 3d</h2>
				<div class="process-description">
					<p>
          Wrapping up the design phase and <strong>NOT</strong> worrying about my
          animation capabilities as though I had another animator on standby was
          one of the reasons this project came to life.
					</p>
				</div>
			</div>

			<!-- Decorative Lines with Image Containers -->
			<div class="decorative-lines">
				<svg
					class="grid-lines-svg"
					preserveAspectRatio="none"
					viewBox="0 0 1512 400"
					xmlns="http://www.w3.org/2000/svg"
				>
					<!-- Lines will be generated by JavaScript -->
				</svg>

				<!-- Image Container Overlay -->
				<div class="sketch-container-wrapper">
					<div class="sketch-container-grid">
						<!-- Row 1: Main Sketch Containers -->
						<div
							class="sketch-container main-sketch"
							data-grid-column="1"
							data-grid-row="1"
						>
            <CldImage
              src={projectData?.sketches?.[0]?.src || ""}
              alt={projectData?.sketches?.[0]?.alt || "Main sketch"}
              class="sketch-image"
            />
						</div>

						<div
							class="sketch-container mobile-sketch-1"
							data-grid-column="2"
							data-grid-row="1"
						>
							<!-- Image will be placed here later -->
						</div>

						<div
							class="sketch-container mobile-sketch-2"
							data-grid-column="3"
							data-grid-row="1"
						>
							<!-- Image will be placed here later -->
						</div>

						<!-- Row 2: Text Blocks - Equal Width -->
						<div class="sketch-container text-block-1">
							<div class="text-content">
								<p>
                There are several ways to rig a fake 3D box in aftereffects. You
                could I wanted one that will allow me the freedom of having the
                shapes as flat 2D if I wanted to un-wrap it. This is because
                this where I had texts and I needed change its content later on.
								</p>
							</div>
						</div>

						<div class="sketch-container text-block-2">
							<!-- Text content will go here -->
						</div>

						<!-- Row 3: Full Width Text Block -->
						<div class="sketch-container text-block-full">
							<!-- Challenge Section -->
							<div class="challenge-section">
								<div class="challenge-badge">
									<p class="challenge-label">challenge</p>
									<p class="challenge-number">TWO</p>
								</div>
								<h2 class="challenge-title">the rigs.</h2>
							</div>
						</div>
					</div>
				</div>
			</div>
		</div>
	</section>

	<!-- SPEED LINES SECTION -->
	<section class="project-showcase-section">
		<div class="project-showcase-container">
			<!-- Top Grid: wraps the two top placeholders -->
			<div class="project-showcase-top-grid">
				<div class="project-showcase-placeholder"></div>
				<div class="project-showcase-placeholder"></div>
				<div class="project-showcase-placeholder"></div>
				<div class="project-showcase-placeholder"></div>
				<div class="project-showcase-placeholder"></div>
      <div
        class="project-showcase-placeholder project-showcase-description-block"
      >
					<p class="project-showcase-description">
          This project only had the 4-major features of the app as the script,
          meant for me to work with. The first assumption was thinking what
          needed to be done was showing off the mobile app interfaces but then
          this is a teaser. This wouldn't be the first of its kind to come into
          the market. It needed a second or two of "Please do not skip me."
					</p>
				</div>
			</div>
			
			<!-- Bottom Grid with 3 Image Placeholders -->
			<div class="project-showcase-bottom-grid">
				<div class="project-showcase-placeholder bottom-left"></div>
				<div class="project-showcase-placeholder bottom-right"></div>
				<div class="project-showcase-placeholder bottom-full"></div>
			</div>

			<!-- Move description to the end of the top grid section -->
		</div>
	</section>

	<!-- CREDITS SECTION -->
	<section class="credits-section">
		<div class="credits-container">
			<div class="credits-grid">
				<!-- 8 placeholder squares -->
				<div class="credits-placeholder"></div>
				<div class="credits-placeholder"></div>
				<div class="credits-placeholder"></div>
				<div class="credits-placeholder"></div>
				<div class="credits-placeholder"></div>
				<div class="credits-placeholder"></div>
				<div class="credits-placeholder"></div>
				<div class="credits-placeholder"></div>
				
				<!-- First text block (top-middle) -->
				<div class="credits-text-block credits-text-top">
					<div class="credits-labels">
						<p>Client</p>
						<p>Sound Design</p>
						<p>Motion Design</p>
					</div>
					<div class="credits-values">
						<p>Project Name</p>
						<p>Your Name</p>
						<p>Your Name</p>
					</div>
				</div>
				
				<!-- Second text block (bottom-middle) -->
				<div class="credits-text-block credits-text-bottom">
					<div class="credits-labels">
						<p>Script</p>
						<p>Director</p>
						<p>Creative Direction</p>
					</div>
					<div class="credits-values">
						<p>Contributor Name</p>
						<p>Contributor Name</p>
						<p>Your Name</p>
					</div>
				</div>
			</div>
		</div>
	</section>
  
  <script>
	// @ts-check
	import Smooothy from "smooothy";
	import { gsap } from "gsap";
	import { ScrollTrigger } from "gsap/ScrollTrigger";

	// Register GSAP plugins
	gsap.registerPlugin(ScrollTrigger);

	// Navigation active state management
	const navLinks = document.querySelectorAll(".nav a");
	const headerLogo = document.querySelector(".header-logo") as HTMLElement;
	const allNavElements = [...navLinks, headerLogo];

	// Set header logo as active by default (home/landing page)
	if (headerLogo) {
		headerLogo.classList.add("active");
	}

	navLinks.forEach((link) => {
		link.addEventListener("click", () => {
			// Remove active class from all nav elements
			allNavElements.forEach((element) => {
				if (element) element.classList.remove("active");
			});
			// Add active class to clicked link
			link.classList.add("active");
			// Update URL to show the clicked link's href
			const href = link.getAttribute("href");
			if (href) {
				window.history.pushState(null, "", href);
			}
		});
	});

	// Add click handler for header logo
	if (headerLogo) {
		headerLogo.addEventListener("click", (e) => {
			e.preventDefault(); // Prevent default anchor behavior
			// Remove active class from all nav elements
			allNavElements.forEach((element) => {
				if (element) element.classList.remove("active");
			});
			// Add active class to header logo
			headerLogo.classList.add("active");
			// Update URL to show home route
			window.history.pushState(null, "", "#");
			// Scroll to top of page
			window.scrollTo({ top: 0, behavior: "smooth" });
		});
	}

	// GSAP Parallax Effect - Hero Content Wrapper
	const heroContentWrapper = document.querySelector(".hero-content-wrapper");
	const videoSection = document.querySelector(".video-section");
	const scrollContainer = document.querySelector(".scroll-container");

	if (heroContentWrapper && videoSection) {
		// Ease-out for fast start, slow end when scrolling back
		const easeOut = "power2.out"; // Fast start, slow end - perfect for scroll back
		
		// Calculate distance based on viewport height (since hero is 80vh)
		// Move it by 100vh to ensure it's completely out of view
		const moveDistance = -(window.innerHeight * 0.15); // Move by full viewport height
		
		console.log("Hero move distance:", moveDistance, "vh");
		
		// Move up animation with ease-out and depth effect - responsive when scrolling back
		gsap.to(heroContentWrapper, {
			y: moveDistance,
			scale: 0.85, // Slight scale down for depth as it moves away
			ease: easeOut,
			scrollTrigger: {
				trigger: ".video-section",
				start: "top bottom-=300", // Start even earlier (200px before main sketch)
				end: "center center", // End when center of process section hits center of viewport (halfway through)
				scrub: 0.2, // Faster response for quicker return when scrolling back
				markers: false,
			},
		});

		// Enhanced fade out with custom ease
		gsap.to(heroContentWrapper, {
			opacity: 0,
			ease: "power3.out", // More dramatic ease curve
			scrollTrigger: {
				trigger: ".hero-section",
				start: "center top", // Starts later - when center of hero hits top
				end: () => `+=${(videoSection as HTMLElement).offsetTop}`, // Match the movement end
				scrub: 0, // Slightly slower for smoother fade
				markers: false,
			},
		});
	}

	// GSAP Snap Scrolling for Video Section
	if (scrollContainer && videoSection) {
		// Use ScrollTrigger.scrollerProxy for custom scroll container
		ScrollTrigger.scrollerProxy(scrollContainer, {
			scrollTop(value?: number) {
				if (arguments.length && value !== undefined) {
					scrollContainer.scrollTop = value;
				}
				return scrollContainer.scrollTop;
			},
			getBoundingClientRect() {
				return {
					top: 0,
					left: 0,
					width: window.innerWidth,
					height: window.innerHeight,
				};
			},
		});

		// Create snap point at video section
		ScrollTrigger.create({
			trigger: ".video-section",
			scroller: scrollContainer,
			start: "top 60%",
			end: "top 40%",
			onEnter: () => {
				gsap.to(scrollContainer, {
					scrollTop: (videoSection as HTMLElement).offsetTop,
					duration: 0.8,
					ease: "power2.inOut",
					overwrite: true,
				});
			},
			onEnterBack: () => {
				gsap.to(scrollContainer, {
					scrollTop:
            (videoSection as HTMLElement).offsetTop - window.innerHeight,
					duration: 0.8,
					ease: "power2.inOut",
					overwrite: true,
				});
			},
			markers: false,
		});
		
		// Refresh ScrollTrigger after setup
		ScrollTrigger.refresh();
	}

	// Process sections parallax animations - loop through all sections
	const processSections = document.querySelectorAll(".process-section");
	
	processSections.forEach((section) => {
		// Main Sketch parallax animation
		const mainSketch = section.querySelector(".main-sketch");

		if (mainSketch) {
			gsap.from(mainSketch, {
				y: -350, // Move down 350px as you scroll
				scrollTrigger: {
					trigger: section, // Trigger when this specific process section enters viewport
					start: "top bottom", // Start when top of process section hits bottom of viewport
					end: "center center", // End when center of process section hits center of viewport (halfway through)
					scrub: 1, // Smooth parallax effect tied to scroll
					markers: false,
				},
			});
		}

		// Mobile Sketch containers - reverse movement with offset
		const mobileSketch1 = section.querySelector(".mobile-sketch-1");
		const mobileSketch2 = section.querySelector(".mobile-sketch-2");

		if (mobileSketch1) {
			gsap.from(mobileSketch1, {
				y: 350, // Start below and move up (reverse of main sketch)
				scrollTrigger: {
					trigger: section, // Trigger when this specific process section enters viewport
					start: "top bottom-=100", // Start earlier (100px before main sketch)
					end: "center center", // End when center of process section hits center of viewport (halfway through)
					scrub: 1, // Smooth parallax effect tied to scroll
					markers: false,
				},
			});
		}

		if (mobileSketch2) {
			gsap.from(mobileSketch2, {
				y: 350, // Start below and move up (reverse of main sketch)
				scrollTrigger: {
					trigger: section, // Trigger when this specific process section enters viewport
					start: "top bottom-=500", // Start even earlier (200px before main sketch)
					end: "center center", // End when center of process section hits center of viewport (halfway through)
					scrub: 1, // Smooth parallax effect tied to scroll
					markers: false,
				},
			});
		}
	});

  // Initialize Swiper Hero Carousel
  const heroCarousel = document.getElementById("hero-carousel") as HTMLElement;
	  
		// Gallery Modal Functionality
	const modal = document.getElementById("video-modal");
	const modalVideo = document.getElementById(
    "modal-video-player"
	) as HTMLVideoElement;
	const modalVideoSource = document.getElementById(
    "modal-video-source"
	) as HTMLSourceElement;
	const modalClose = document.getElementById("modal-close");
	const galleryItems = document.querySelectorAll(".gallery-item");
	  
		// Open modal with video
		function openModal(videoUrl: string) {
		  if (modal && modalVideo && modalVideoSource) {
			modalVideoSource.src = videoUrl;
			modalVideo.load();
			modal.classList.add("active");
			document.body.style.overflow = "hidden"; // Prevent background scrolling
		  }
		}
	  
		// Close modal
		function closeModal() {
		  if (modal && modalVideo) {
			modal.classList.remove("active");
			modalVideo.pause();
			modalVideo.currentTime = 0;
			document.body.style.overflow = ""; // Re-enable scrolling
		  }
		}
	  
		// Add click handlers to gallery items
		galleryItems.forEach((item) => {
		item.addEventListener("click", () => {
			const videoUrl = item.getAttribute("data-video");
			if (videoUrl) {
			  openModal(videoUrl);
			}
		  });
		});
	  
		// Close modal on close button click
	modalClose?.addEventListener("click", closeModal);
	  
		// Close modal on outside click
	modal?.addEventListener("click", (e) => {
		  if (e.target === modal) {
			closeModal();
		  }
		});
	  
		// Close modal on Escape key
	document.addEventListener("keydown", (e) => {
		if (e.key === "Escape" && modal?.classList.contains("active")) {
			closeModal();
		  }
		});
	  
		// Pause marquee on hover
	const marqueeContent = document.querySelector(
    ".marquee-content"
	) as HTMLElement;
	const marqueeContainer = document.querySelector(".marquee-container");

	marqueeContainer?.addEventListener("mouseenter", () => {
		  if (marqueeContent) {
			marqueeContent.style.animationPlayState = "paused";
		  }
		});
	  
	marqueeContainer?.addEventListener("mouseleave", () => {
		  if (marqueeContent) {
			marqueeContent.style.animationPlayState = "running";
		}
	});

	// SVG Grid Lines Generator
	function generateGridLines() {
    const svgs = document.querySelectorAll(
      ".grid-lines-svg"
    ) as NodeListOf<SVGElement>;
		if (!svgs || svgs.length === 0) return;

		// Generate lines for each SVG element
		svgs.forEach((svg) => {
			const container = svg.parentElement;
			if (!container) return;

		// Configuration
		const config = {
			lineSpacing: 22, // Spacing between lines in pixels
			topSegmentStart: 0.24, // 333.508 / 1395 ≈ 0.24
			topSegmentEnd: 0.434, // 605.368 / 1395 ≈ 0.434
			middleSegmentEnd: 0.706, // 985.368 / 1395 ≈ 0.706
			bottomSegmentEnd: 0.901, // 1257.23 / 1395 ≈ 0.901
			thickStrokeWidth: 9,
			thinStrokeWidth: 1,
			strokeColor: "#ACAAA3",
			startOffset: 5, // Minimal offset to prevent cut-off
		};

		// Clear existing lines
		svg.innerHTML = "";

		// Calculate container width and number of lines
		const containerWidth = container.offsetWidth;

		// Use full container width for viewBox
		svg.setAttribute("viewBox", `0 0 ${containerWidth} 400`);

		// Calculate available width for lines (account for left/right padding of overlay grid)
		let horizontalPadding = 0;
		const overlayGridForPadding = container.querySelector(
        ".sketch-container-grid"
		) as HTMLElement | null;
		if (overlayGridForPadding) {
			const cs2 = getComputedStyle(overlayGridForPadding);
			const padLeft = parseFloat(cs2.paddingLeft || "0");
			const padRight = parseFloat(cs2.paddingRight || "0");
			horizontalPadding = padLeft + padRight;
		}
		const availableWidth =
			containerWidth - horizontalPadding - config.startOffset * 2;

		// Keep constant spacing but distribute leftover equally on both sides
		const spacing = config.lineSpacing;
		const numLines = Math.floor(availableWidth / spacing) + 1; // number of lines so last index fits in width
		const spanWidth = (numLines - 1) * spacing; // distance from first to last line
		const sideRemainder = Math.max(availableWidth - spanWidth, 0);
		const sidePadding = sideRemainder / 2; // equal gap on left and right inside overlay padding

		// Start position: left overlay padding + inner offset + equalized side padding
		const leftOverlayPadding = overlayGridForPadding
        ? parseFloat(getComputedStyle(overlayGridForPadding).paddingLeft || "0")
			: 0;
		const adjustedStartOffset =
			leftOverlayPadding + config.startOffset + sidePadding;

		// Get the actual SVG height from viewBox or container
		const svgHeight = (svg as any).viewBox.baseVal.height || 400;

		// Read top/bottom padding from the overlay grid so thick segments can form a border
		let topPaddingPx = 0;
		let bottomPaddingPx = 0;
		const overlayGrid = container.querySelector(
        ".sketch-container-grid"
		) as HTMLElement | null;
		if (overlayGrid) {
			const cs = getComputedStyle(overlayGrid);
			topPaddingPx = parseFloat(cs.paddingTop || "0");
			bottomPaddingPx = parseFloat(cs.paddingBottom || "0");
		}

		// Generate lines
		for (let i = 0; i < numLines; i++) {
			const x = adjustedStartOffset + i * spacing;
			const groupIndex = Math.floor(i / 5); // Group every 5 lines for future animation

			// Create group for this line (for future animation control)
			const group = document.createElementNS(
				"http://www.w3.org/2000/svg",
          "g"
			);
			group.classList.add("grid-line-group");
			group.setAttribute("data-group", groupIndex.toString());
			group.setAttribute("data-line", i.toString());

			// Top segment (thick stroke) - from very top to the start of the middle (acts like border)
			const topLine = document.createElementNS(
				"http://www.w3.org/2000/svg",
          "path"
			);
			topLine.setAttribute("d", `M${x} ${topPaddingPx}V0`);
			topLine.setAttribute("stroke", config.strokeColor);
			topLine.setAttribute(
				"stroke-width",
          config.thickStrokeWidth.toString()
			);
			topLine.classList.add("grid-line-top");
			group.appendChild(topLine);

			// Middle segment (thin stroke) - spans the grid area between paddings
			const middleLine = document.createElementNS(
				"http://www.w3.org/2000/svg",
          "path"
			);
			middleLine.setAttribute(
				"d",
          `M${x} ${topPaddingPx}V${svgHeight - bottomPaddingPx}`
			);
			middleLine.setAttribute("stroke", config.strokeColor);
			middleLine.setAttribute(
				"stroke-width",
          config.thinStrokeWidth.toString()
			);
			middleLine.classList.add("grid-line-middle");
			group.appendChild(middleLine);

			// Bottom segment (thick stroke) - from end of middle to very bottom (acts like border)
			const bottomLine = document.createElementNS(
				"http://www.w3.org/2000/svg",
          "path"
			);
			bottomLine.setAttribute(
				"d",
          `M${x} ${svgHeight}V${svgHeight - bottomPaddingPx}`
			);
			bottomLine.setAttribute("stroke", config.strokeColor);
			bottomLine.setAttribute(
				"stroke-width",
          config.thickStrokeWidth.toString()
			);
			bottomLine.classList.add("grid-line-bottom");
			group.appendChild(bottomLine);

		svg.appendChild(group);
	}
		}); // End forEach loop for each SVG
	}

	// Update SVG height based on container grid height
	function updateSVGHeight() {
		const processSections = document.querySelectorAll(".process-section");
		
		processSections.forEach((section) => {
			const svg = section.querySelector(".grid-lines-svg") as SVGElement;
			const containerWrapper = section.querySelector(
        ".sketch-container-wrapper"
			) as HTMLElement;
			const decorativeLines = section.querySelector(
        ".decorative-lines"
			) as HTMLElement;

			if (!svg || !containerWrapper || !decorativeLines) return;

			// Get the actual height of the container wrapper
			const gridHeight = containerWrapper.offsetHeight;

			// Update decorative-lines container height
			decorativeLines.style.height = `${gridHeight}px`;

			// Get current viewBox
			const viewBox = svg.getAttribute("viewBox");
			if (!viewBox) return;

			const [x, y, width] = viewBox.split(" ").map(Number);

			// Update viewBox height to match grid height
			svg.setAttribute("viewBox", `${x} ${y} ${width} ${gridHeight}`);
		});

		// Regenerate lines with new height for all sections
		generateGridLines();
	}

	// Call after grid generation and on resize
	window.addEventListener("DOMContentLoaded", () => {
		setTimeout(() => {
			generateGridLines();
			updateSVGHeight();
		}, 100);
	});

	// Also try to initialize immediately if DOM is already loaded
	if (document.readyState === "loading") {
		document.addEventListener("DOMContentLoaded", () => {
			setTimeout(() => {
				generateGridLines();
				updateSVGHeight();
			}, 100);
		});
	} else {
		setTimeout(() => {
			generateGridLines();
			updateSVGHeight();
		}, 100);
	}

	// Update on resize
	let resizeTimeout: ReturnType<typeof setTimeout>;
	window.addEventListener("resize", () => {
		clearTimeout(resizeTimeout);
		resizeTimeout = setTimeout(() => {
			updateSVGHeight();
      // Force Smooothy to recalculate viewport on resize with 1512px constraint
      if (typeof heroCarouselInstance !== "undefined") {
        heroCarouselInstance.resize();
        // Force viewport constraint after resize
        if (
          heroCarouselInstance.viewport &&
          heroCarouselInstance.viewport.wrapperWidth > 1512
        ) {
          heroCarouselInstance.viewport.wrapperWidth = 1512;
        }
      }
      if (typeof thumbsCarousel !== "undefined") {
        thumbsCarousel.resize();
        // Force viewport constraint after resize
        if (thumbsCarousel.viewport && thumbsCarousel.viewport.wrapperWidth > 1512) {
          console.log("Styleframes carousel - forcing viewport to 1512px");
          thumbsCarousel.viewport.wrapperWidth = 1512;
        }
      }
		}, 250);
	});

  // ==================== HERO CAROUSEL WITH SMOOOTHY ====================
  const heroCarouselElement = document.getElementById(
    "hero-carousel"
  ) as HTMLElement;
  let heroCarouselInstance: any;

  if (heroCarouselElement) {
    console.log("Hero carousel found:", heroCarouselElement);

    // Initialize Smooothy for hero carousel
    heroCarouselInstance = new Smooothy(heroCarouselElement, {
      infinite: true,
			snap: false,
      dragSensitivity: 0.019,
			lerpFactor: 0.35,
      scrollInput: true,
      onUpdate: (instance) => {
        // Force viewport to think we're on a 1512px screen
        if (instance.viewport && instance.viewport.wrapperWidth > 1512) {
          instance.viewport.wrapperWidth = 1512;
        }
      },
    });

    // Auto-scroll functionality for hero carousel
    let heroAutoScrollSpeed = -0.003; // Slower speed for hero carousel
    let heroIsPaused = false;

    // Pause on hover for hero carousel
    heroCarouselElement.addEventListener("mouseenter", () => {
      heroIsPaused = true;
    });

    heroCarouselElement.addEventListener("mouseleave", () => {
      heroIsPaused = false;
    });

    // Animation loop for hero carousel auto-scroll using GSAP ticker
    function updateHero() {
      if (!heroIsPaused) {
        heroCarouselInstance.target += heroAutoScrollSpeed;
      }
    }

    // Use GSAP ticker for smooth updates
    gsap.ticker.add(updateHero);
    gsap.ticker.add(heroCarouselInstance.update.bind(heroCarouselInstance));
				} else {
    console.error("Hero carousel not found in DOM");
  }

  // ==================== STYLEFRAMES THUMBS WITH SMOOOTHY ====================
  // Find the second carousel (styleframes thumbs) - it's the second .carousel-wrapper
  const carouselWrappers = document.querySelectorAll(".carousel-wrapper");
  const thumbsRail = carouselWrappers[1] as HTMLElement; // Second carousel is the thumbs rail
  let thumbsCarousel: any;
  
  console.log("Total carousel wrappers found:", carouselWrappers.length);
  console.log("First carousel (hero):", carouselWrappers[0]);
  console.log("Second carousel (thumbs):", carouselWrappers[1]);

  // Get styleframeSet from data attribute
  const previewContainer = document.querySelector(
    ".styleframes-preview"
  ) as HTMLElement;
  const styleframeSet = previewContainer
    ? JSON.parse(previewContainer.getAttribute("data-styleframes") || "[]")
    : [];

  if (thumbsRail) {
    console.log("Thumbs rail found:", thumbsRail);

    // Initialize Smooothy for thumbs rail - DRAG ONLY, NO AUTO-SCROLL
    thumbsCarousel = new Smooothy(thumbsRail, {
      infinite: false, // No infinite loop - this naturally prevents over-scrolling
      snap: true, // Enable snapping for smooth drag-to-stop behavior
      dragSensitivity: 0.019, // Same drag sensitivity as hero
      lerpFactor: 0.35, // Same lerp factor as hero
      scrollInput: true,
      onUpdate: (instance) => {
        // Force viewport to think we're on a 1512px screen
        if (instance.viewport && instance.viewport.wrapperWidth > 1512) {
          console.log("Forcing viewport to 1512px");
          instance.viewport.wrapperWidth = 1512;
        }
        // Let Smooothy handle bounds naturally with infinite: false
      },
    });

    // NO auto-scroll functionality - drag only
    // But we still need GSAP ticker for drag animations
    gsap.ticker.add(thumbsCarousel.update.bind(thumbsCarousel));
    console.log("Styleframes carousel initialized - drag only, no auto-scroll");

    // ==================== DYNAMIC PREVIEW IMAGE SYSTEM ====================
    // Get all carousel items and preview image
    const carouselItems = thumbsRail.querySelectorAll(".carousel-item-inner");
    const previewImage = document.getElementById("current-styleframe") as HTMLImageElement;
    const detector = document.getElementById("styleframe-detector");
    const counterNumber = document.querySelector(".counter-number.current") as HTMLElement;

    function updatePreviewImage() {
      if (!detector || !previewImage) return;
      
      const detectorRect = detector.getBoundingClientRect();
      const detectorLeft = detectorRect.left;
      const detectorRight = detectorRect.right;
      
      carouselItems.forEach((item, index) => {
        const rect = item.getBoundingClientRect();
        const centerX = (rect.left + rect.right) / 2;
        
        // Check if item center intersects with detector
        if (centerX >= detectorLeft && centerX <= detectorRight) {
          // Get the image from this carousel item
          const carouselImage = item.querySelector(".carousel-image2") as HTMLImageElement;
          if (carouselImage && carouselImage.src) {
            (previewImage as HTMLImageElement).src = carouselImage.src;
            (previewImage as HTMLImageElement).alt = carouselImage.alt || "Current Styleframe";
            
            // Update the counter to show current item number (1-based)
            if (counterNumber) {
              counterNumber.textContent = (index + 1).toString();
            }
            
            console.log("Preview updated with:", carouselImage.src, "Counter:", index + 1);
          }
        }
      });
    }

    // Update on scroll/drag
    gsap.ticker.add(updatePreviewImage);

    // Initial update
    updatePreviewImage();
  } else {
    console.error("Thumbs rail (second carousel) not found in DOM");
	}

	// ==================== STYLEFRAMES SCROLL SYNC WITH VIEW TIMELINES ====================
  const revealStageEl = document.querySelector(".reveal-stage") as HTMLElement;
  const textBlocksEls = document.querySelectorAll(
    ".styleframes-text .text-block"
  ) as NodeListOf<HTMLElement>;
	
	// Check browser support for view timelines
  const supportsViewTimeline = CSS.supports("animation-timeline", "view()");
  console.log("Browser supports view timelines:", supportsViewTimeline);
	
	// Force initial states of preview slots
  const slot1 = document.querySelector(
    '.preview-slot[data-slot="1"]'
  ) as HTMLElement;
  const slot2 = document.querySelector(
    '.preview-slot[data-slot="2"]'
  ) as HTMLElement;
  const slot3 = document.querySelector(
    '.preview-slot[data-slot="3"]'
  ) as HTMLElement;
	
	if (slot1 && slot2 && slot3) {
		// Force initial positions with inline styles (higher specificity)
    slot1.style.setProperty("transform", "translateY(0)", "important");
    slot2.style.setProperty("transform", "translateY(100%)", "important");
    slot3.style.setProperty("transform", "translateY(100%)", "important");

    console.log("Initial slot transforms set:", {
			slot1: window.getComputedStyle(slot1).transform,
			slot2: window.getComputedStyle(slot2).transform,
      slot3: window.getComputedStyle(slot3).transform,
		});
		
		// After a brief delay, remove important and let CSS animations take over
		setTimeout(() => {
			if (supportsViewTimeline) {
        slot1.style.removeProperty("transform");
        slot2.style.removeProperty("transform");
        slot3.style.removeProperty("transform");
        console.log("Inline styles removed, CSS animations taking over");
			}
		}, 500);
	}

	if (revealStageEl && textBlocksEls.length > 0) {
		// Use FIXED inset based on known sticky position instead of dynamic calculation
		// The reveal-stage is sticky at top: 12vh, height: 60vh
		// So: top inset = 12vh, bottom inset = 100vh - 12vh - 60vh = 28vh
    const fixedInsetValue = "12% 28%"; // Simplified percentages
		
    console.log("Using fixed view timeline inset:", fixedInsetValue);
		
		// Apply fixed inset to each text-block
		textBlocksEls.forEach((block) => {
      (block.style as any).viewTimelineAxis = "block";
			(block.style as any).viewTimelineInset = fixedInsetValue;
		});
		
		// Force a reflow to ensure timelines are registered
		void revealStageEl.offsetHeight;
		
    console.log("View timelines initialized with fixed inset");
  }
</script>

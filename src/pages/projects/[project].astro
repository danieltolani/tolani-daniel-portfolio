---
import { CldImage } from "astro-cloudinary";
import data from "../../data/projects/index";
import type { ProjectData } from "../../types/project";
import Layout from "../../layouts/Layout.astro";
import Header from "../../components/Header.astro";
import Footer from "../../components/Footer.astro";
import "../../styles/portfolio.css";

export function getStaticPaths() {
  return data.map((item) => ({
    params: { project: item.project },
  }));
}

const { project } = Astro.params;

const projectData = data.find((item) => item.project === project) as ProjectData;

// Create dynamic styleframe set based on project data
const styleframeSet = projectData?.styleframes?.map((item) => item.src) || [];

// Resolve video sources:
// - If a src starts with "/", treat as local/static path
// - Otherwise, treat as Cloudinary public ID and build URL from env cloud name
const cloudName = import.meta.env.PUBLIC_CLOUDINARY_CLOUD_NAME;

let resolvedVideoSrc = projectData?.videoSrc as string | undefined;
let resolvedWireframeVideoSrc = projectData?.wireframeVideoSrc as string | undefined;
let resolvedWireframeVideoSrc2 = projectData?.wireframeVideoSrc2 as string | undefined;

if (resolvedVideoSrc && !resolvedVideoSrc.startsWith("/")) {
  resolvedVideoSrc = `https://res.cloudinary.com/${cloudName}/video/upload/f_auto,q_auto/${resolvedVideoSrc}.mp4`;
}

if (resolvedWireframeVideoSrc && !resolvedWireframeVideoSrc.startsWith("/")) {
  resolvedWireframeVideoSrc = `https://res.cloudinary.com/${cloudName}/video/upload/f_auto,q_auto/${resolvedWireframeVideoSrc}.mp4`;
}

if (resolvedWireframeVideoSrc2 && !resolvedWireframeVideoSrc2.startsWith("/")) {
  resolvedWireframeVideoSrc2 = `https://res.cloudinary.com/${cloudName}/video/upload/f_auto,q_auto/${resolvedWireframeVideoSrc2}.mp4`;
}
---

<Layout>
  <div class={`page-container scroll-container project-${project}`}>
    <!-- Header Navigation -->
    <Header />

    <!-- Hero Section -->
    <main class="hero-section snap-section">
      <div class="hero-content-wrapper">
        <div class="hero-content" id="hero-card">
          <!-- Project Title & Description -->
          <div class="hero-desc">
            <div class="hero-text">
              <div class="hero-title-row">
                <h1 class="hero-title">
                  <div set:html={projectData?.title} />
                </h1>
                {projectData.inProduction && (
                  <span class="wip-tag">IN PRODUCTION</span>
                )}
              </div>
              <div class="hero-description-wrapper">
                <p class="hero-description">
                  {projectData?.description1}
                </p>
                <button class="read-more-button" aria-expanded="false">Read more</button>
              </div>
            </div>

            <!-- Thumbnail Carousel -->
            <div class="carousel-container">
              {projectData.project === "faramove-campaign" ? (
                <div class="campaign-banner-wrapper">
                  <div class="campaign-vehicle-image">
                    <img 
                      src="/png/FARAMOVE/FARAMOVE_Campaign/FRMV-CAMPAIGN-MARUWA-BLUE.png" 
                      alt="Faramove Delivery Vehicle" 
                    />
                  </div>
                  <div class="campaign-marquee-banner">
                    <div class="campaign-marquee-content">
                      <span class="city-name">Lagos</span>
                      <span class="separator">~</span>
                      <span class="city-name">Ibadan</span>
                      <span class="separator">~</span>
                      <span class="city-name">Abeokuta</span>
                      <span class="separator">~</span>
                      <span class="city-name">Osun</span>
                      <span class="separator">~</span>
                      <span class="city-name">Abuja</span>
                      <span class="separator">~</span>
                    </div>
                    <div class="campaign-marquee-content" aria-hidden="true">
                      <span class="city-name">Lagos</span>
                      <span class="separator">~</span>
                      <span class="city-name">Ibadan</span>
                      <span class="separator">~</span>
                      <span class="city-name">Abeokuta</span>
                      <span class="separator">~</span>
                      <span class="city-name">Osun</span>
                      <span class="separator">~</span>
                      <span class="city-name">Abuja</span>
                      <span class="separator">~</span>
                    </div>
                  </div>
                </div>
              ) : projectData.project === "pinata-audio" ? (
                <div class="campaign-banner-wrapper">
                  <div class="campaign-marquee-banner" style="background: none;">
                    <img 
                      src="/png/BWI/BWI-HERO-BANNER.png" 
                      alt="Pinata Audio Banner" 
                      style="width: 100%; height: 100%; object-fit: cover;"
                    />
                  </div>
                </div>
              ) : (
                <div class="carousel-wrapper" id="hero-carousel" data-slider>
                  {
                    (projectData?.styleframes || []).map((item, index) => (
                      <div class="carousel-item">
                        <div
                          class="carousel-item-inner"
                          data-image-url={styleframeSet[index]}
                          data-image-index={index}
                        >
                          {item.src.startsWith("/") ? (
                            <img
                              class="carousel-image2"
                              src={item.src}
                              alt={`Styleframe ${index}`}
                            />
                          ) : (
                            <CldImage
                              class="carousel-image2"
                              src={item.src}
                              alt={`Styleframe ${index}`}
                            />
                          )}
                          <span class="carousel-number">STY-{index + 1}</span>
                        </div>
                      </div>
                    ))
                  }
                </div>
              )}
            </div>
          </div>

          <!-- Project Metadata -->
          <div class="project-metadata">
            <div class="metadata-item">
              <span class="metadata-label">YEAR</span>
              <span class="metadata-value">{projectData?.metadata?.year || "N/A"}</span>
            </div>
            <div class="metadata-item">
              <span class="metadata-label">ROLE</span>
              <span class="metadata-value">{projectData?.metadata?.role || "N/A"}</span>
            </div>
            <div class="metadata-item">
              <span class="metadata-label">TOOLS</span>
              <span class="metadata-value">{projectData?.metadata?.tools || "N/A"}</span>
            </div>
            <div class="metadata-item">
              <span class="metadata-label">TYPE</span>
              <span class="metadata-value">{projectData?.metadata?.type || "N/A"}</span>
            </div>
          </div>
        </div>
      </div>
    </main>

    <!-- VIDEO SECTION -->
    {(projectData?.videoId || projectData?.videoSrc) && (
      <section class="snap-section video-section">
        <div class="video-embed-wrapper">
          <!-- Video Play Helper (Follows Cursor) -->
          <div class="video-play-helper">
            <div class="play-helper-circle">
              <svg width="164" height="164" viewBox="0 0 164 164" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="82" cy="82" r="81.5" stroke="white" stroke-dasharray="11 0 30 2"/></svg>

            </div>
            <span class="play-helper-text">UNMUTE</span>
          </div>
          <!-- Click Overlay for Restart/Unmute -->
          <div class="video-click-overlay" style="position:absolute;top:0;left:0;width:100%;height:100%;z-index:15;"></div>

          {projectData.videoId ? (
          <iframe
            src={`https://player.vimeo.com/video/${projectData.videoId}?badge=0&autopause=0&player_id=0&app_id=58479&autoplay=1&loop=1&muted=1&title=0&byline=0&portrait=0&transparent=0`}
            frameborder="0"
            allow="autoplay; fullscreen; picture-in-picture; clipboard-write; encrypted-media; web-share"
            referrerpolicy="strict-origin-when-cross-origin"
            style="position:absolute;top:0;left:0;width:100%;height:100%;"
            title={projectData.videoTitle || "Project Video"}
            allowfullscreen
          ></iframe>
          ) : (
            <video
              src={resolvedVideoSrc}
              controls
              autoplay
              muted
              loop
              playsinline
              preload="metadata"
              style="position:absolute;top:0;left:0;width:100%;height:100%;object-fit:cover;"
              title={projectData.videoTitle || "Project Video"}
            >
              Your browser does not support the video tag.
            </video>
          )}
        </div>
      </section>
    )}
    <script src="https://player.vimeo.com/api/player.js"></script>

    <script>
      // @ts-ignore
      declare const Vimeo: any;

      // Hide Vimeo side dock elements
      function hideVimeoSideDock() {
        const iframe = document.querySelector(
          ".video-embed-wrapper iframe"
        ) as HTMLIFrameElement;
        if (iframe) {
          iframe.addEventListener("load", () => {
            try {
              const iframeDoc =
                iframe.contentDocument || iframe.contentWindow?.document;
              if (iframeDoc) {
                // Create and inject CSS to hide side dock elements
                const style = iframeDoc.createElement("style");
                style.textContent = `
								.SideDock_module_sidedockInner__eeb5e08f,
								[class*="SideDock_module_sidedockInner"],
								[class*="sidedockInner"] {
									display: none !important;
									visibility: hidden !important;
									opacity: 0 !important;
								}
							`;
                iframeDoc.head.appendChild(style);
              }
            } catch (e) {
              // Cross-origin restrictions - use overlay instead
              console.log("Using CSS overlay to hide side dock elements");
            }
          });
        }
      }

      // Fade out video overlay when video comes into focus
      function setupVideoOverlayFade() {
        const videoSection = document.querySelector('.video-section');
        const videoOverlay = document.querySelector('.video-overlay');
        
        if (!videoSection || !videoOverlay) return;

        const observer = new IntersectionObserver(
          (entries) => {
            entries.forEach((entry) => {
              // When video section is in view, fade out the overlay
              if (entry.isIntersecting) {
                // Calculate opacity based on intersection ratio
                // Video is "almost in full focus" when intersection ratio > 0.7
                const opacity = Math.max(0, 0.35 * (1 - entry.intersectionRatio / 0.7));
                (videoOverlay as HTMLElement).style.opacity = opacity.toString();
              } else {
                // Reset overlay when scrolling away
                (videoOverlay as HTMLElement).style.opacity = '0.35';
              }
            });
          },
          {
            threshold: Array.from({ length: 21 }, (_, i) => i * 0.05), // Check every 5%
            rootMargin: '0px'
          }
        );

        observer.observe(videoSection);
      }

      // Video Play Helper Logic
      function setupVideoPlayHelper() {
        const videoSection = document.querySelector('.video-section') as HTMLElement;
        const helper = document.querySelector('.video-play-helper') as HTMLElement;
        const clickOverlay = document.querySelector('.video-click-overlay') as HTMLElement;
        
        if (!videoSection || !helper) return;

        // Cursor following
        videoSection.addEventListener('mousemove', (e) => {
          helper.style.left = `${e.clientX}px`;
          helper.style.top = `${e.clientY}px`;
        });

        // Video Play State Detection
        const iframe = videoSection.querySelector('iframe');
        const video = videoSection.querySelector('video');

        // Matrix/HUD text effect
        const specialChars = '$@#%*!?&<>[]{}';
        let scrambleInterval: number;

        const scrambleText = (element: Element, targetText: string) => {
          let iteration = 0;
          
          clearInterval(scrambleInterval);
          
          scrambleInterval = window.setInterval(() => {
            element.textContent = targetText
              .split("")
              .map((letter, index) => {
                if (index < iteration) {
                  return targetText[index];
                }
                return specialChars[Math.floor(Math.random() * specialChars.length)];
              })
              .join("");
            
            if (iteration >= targetText.length) { 
              clearInterval(scrambleInterval);
            }
            
            iteration += 1/3; 
          }, 30);
        };

        // Track mute state (start as true due to autoplay muted)
        let isMuted = true;

        // Function to handle play state
        const setPlaying = (playing: boolean) => {
          const helperText = helper.querySelector('.play-helper-text');
          if (playing) {
            videoSection.classList.add('is-playing');
            if (helperText) {
              if (isMuted) {
                scrambleText(helperText, 'UNMUTE');
              } else {
                scrambleText(helperText, 'PAUSE');
              }
            }
          } else {
            videoSection.classList.remove('is-playing');
            if (helperText) scrambleText(helperText, 'PLAY');
          }
        };

        // Handle Restart & Unmute interaction
        const handleUnmuteInteraction = () => {
          isMuted = false;
          if (clickOverlay) clickOverlay.style.display = 'none'; // Remove overlay to allow normal interaction
          
          if (iframe) {
            // Vimeo
            // @ts-ignore
            if (typeof Vimeo !== 'undefined') {
              // @ts-ignore
              const player = new Vimeo.Player(iframe);
              player.setCurrentTime(0);
              player.setMuted(false);
              player.play();
            }
          } else if (video) {
            video.currentTime = 0;
            video.muted = false;
            video.play();
          }
          // Force update text immediately
          setPlaying(true);
        };
        
        if (clickOverlay) {
          clickOverlay.addEventListener('click', handleUnmuteInteraction);
        }

        if (iframe) {
          // Vimeo
          // @ts-ignore - Vimeo global comes from external script
          const setupVimeo = () => {
            if (typeof Vimeo !== 'undefined') {
              // @ts-ignore
              const player = new Vimeo.Player(iframe);
              player.on('play', () => setPlaying(true));
              player.on('pause', () => setPlaying(false));
              player.on('ended', () => setPlaying(false));
              
              // Sync mute state
              player.getMuted().then((muted: boolean) => {
                isMuted = muted;
                // If checking initially
              });
              
              player.on('volumechange', (data: any) => {
                // data.volume is between 0 and 1
                isMuted = data.volume === 0;
                player.getPaused().then((paused: boolean) => {
                    setPlaying(!paused);
                });
              });
            }
          };

          if (typeof Vimeo !== 'undefined') {
            setupVimeo();
          } else {
            // Fallback if Vimeo API not loaded yet - retry
            iframe.addEventListener('load', setupVimeo);
          }
        } else if (video) {
          // HTML5 Video
          // Sync initial state
          isMuted = video.muted;
          
          video.addEventListener('play', () => setPlaying(true));
          video.addEventListener('pause', () => setPlaying(false));
          video.addEventListener('ended', () => setPlaying(false));
          video.addEventListener('volumechange', () => {
            isMuted = video.muted;
            setPlaying(!video.paused);
          });
        }
      }

      // Run when DOM is ready
      document.addEventListener("DOMContentLoaded", () => {
        hideVimeoSideDock();
        setupVideoOverlayFade();
        setupVideoPlayHelper();
      });
    </script>

    <!-- VIDEO MODAL -->
    <div id="video-modal" class="video-modal">
      <div class="video-modal-content">
        <!-- Close Button -->
        <button id="modal-close" class="modal-close" aria-label="Close modal">
          <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M6 18L18 6M6 6l12 12"></path>
          </svg>
        </button>

        <!-- Modal Video Player -->
        <video
          id="modal-video-player"
          class="modal-video-player"
          controls
          autoplay
        >
          <source id="modal-video-source" src="" type="video/mp4" />
          Your browser does not support the video tag.
        </video>
      </div>
    </div>
  </div>

  <!-- PROCESS BREAKDOWN SECTION -->
  {projectData?.["design-process-title"] && (
    <section class="process-section design-process-breakdown">
      <div class="process-container">
        <!-- Header -->
        <div class="process-header">
          <h2
            class="process-title"
            set:html={projectData?.["design-process-title"] || "Add Title"}
          />
          <div class="process-description">
            <p
              set:html={projectData?.["design-process-par"] || "Add process description"}
            />
          </div>
        </div>

        <!-- Decorative Lines with Image Containers -->
        <div class="decorative-lines">
          <svg
            class="grid-lines-svg"
            preserveAspectRatio="none"
            viewBox="0 0 1512 400"
            xmlns="http://www.w3.org/2000/svg"
          >
            <!-- Lines will be generated by JavaScript -->
          </svg>

          <!-- Image Container Overlay -->
          <div class="sketch-container-wrapper">
            <div class="sketch-container-grid">
              <!-- Row 1: Dynamic Design Process Grid -->
              <div class={`design-sketch-grid layout-${(projectData?.["design-process-images"] || []).length}`}>
                {(projectData?.["design-process-images"] || []).map((img) => (
                  <div class="sketch-container dynamic-sketch-item">
                    {img.src.startsWith("/") ? (
                      <img
                        src={img.src}
                        alt={img.alt || "Design process sketch"}
                        class="sketch-image"
                        id={img.id || undefined}
                      />
                    ) : (
                      <CldImage
                        src={img.src}
                        alt={img.alt || "Design process sketch"}
                        class="sketch-image"
                        id={img.id || undefined}
                      />
                    )}
                  </div>
                ))}
              </div>

              <!-- Row 2: Text Blocks - Equal Width -->
              <div class="sketch-container text-block-1">
                <div class="text-content">
                  <p
                    set:html={projectData?.["design-text-block-1"] ||
                      "Add text block 1 content"}
                  />
                </div>
              </div>

              <div class="sketch-container text-block-2">
                <!-- Text content will go here -->
                <div class="text-content">
                  <p
                    set:html={projectData?.["design-text-block-2"] ||
                      "Add text block 2 content"}
                  />
                </div>
              </div>

              <!-- Row 3: Full Width Text Block -->
              <div class="sketch-container text-block-full">
                <!-- Challenge Section -->
                <div class="challenge-section">
                  <div class="challenge-badge">
                    <p class="challenge-label">challenge</p>
                    <p class="challenge-number">ONE</p>
                  </div>
                  <h2
                    class="challenge-title"
                    set:html={projectData?.["design-challenge-title"] ||
                      "Add challenge title"}
                  />
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>
  )}

  <!-- STYLEFRAMES DETAIL SECTION -->
  {(projectData?.styleframes?.length > 0 || projectData?.["styleframes-breakdown"]) && (
    <section class="styleframes-section">
      {projectData?.styleframes?.length > 0 && (
      <div class="styleframes-container">
        <div class="styleframes-content">
          <!-- Large Preview with Counter -->
          <div
            class="styleframes-preview"
            data-styleframes={JSON.stringify(styleframeSet)}
          >
            <img
              id="current-styleframe"
              src={styleframeSet[0] || ""}
              alt="Current styleframe"
              class="preview-image"
              style={!styleframeSet[0] ? "display: none;" : ""}
            />
            <div class="styleframe-counter">
              <div class="counter-number current">1</div>
              <span class="counter-of">OF</span>
              <div class="counter-number total">
                {(projectData?.styleframes || []).length}
              </div>
            </div>
          </div>

          <!-- bottom rail: masked horizontal rail (placeholders for now) -->
          <div class="carousel-container styleframes-carousel">
            <!-- Fixed detection rectangle on far left -->
            <div class="fixed-detection-rect" id="styleframe-detector"></div>
            <div class="carousel-wrapper" id="hero-carousel" data-slider>
              {
                (projectData?.styleframes || []).map((item, index) => (
                  <div class="carousel-item">
                    <div
                      class="carousel-item-inner"
                      data-image-url={styleframeSet[index]}
                      data-image-index={index}
                    >
                      {item.src.startsWith("/") ? (
                        <img
                          class="carousel-image2"
                          src={item.src}
                          alt={`Styleframe ${index}`}
                        />
                      ) : (
                        <CldImage
                          class="carousel-image2"
                          src={item.src}
                          alt={`Styleframe ${index}`}
                        />
                      )}
                    </div>
                  </div>
                ))
              }
            </div>
          </div>
        </div>
      </div>
      )}

      <!-- Styleframes Breakdown Section -->
      {projectData?.["styleframes-breakdown"] && (
        <div class="styleframes-breakdown" style={projectData.project === "faramove-campaign" ? "margin-top: 0; padding-top: 0;" : ""}>
          <!-- Top: Flex with images (left) and text (right) -->
          <div class="breakdown-top">
            {projectData?.["styleframes-breakdown"]?.["top-images"] && (
              <div class="breakdown-images">
                {projectData["styleframes-breakdown"]["top-images"].map((img) => (
                  !img.src.startsWith("/") && !img.src.includes(".") ? (
                    <video
                      src={`https://res.cloudinary.com/${cloudName}/video/upload/f_auto,q_auto/${img.src}.mp4`}
                      class="breakdown-image"
                      autoplay
                      loop
                      muted
                      playsinline
                      style="object-fit: cover;"
                      oncontextmenu="return false;"
                    ></video>
                  ) : img.src.startsWith("/") ? (
                    <img
                      src={img.src}
                      alt={img.alt}
                      class="breakdown-image"
                    />
                  ) : (
                    <CldImage
                      src={img.src}
                      alt={img.alt}
                      class="breakdown-image"
                    />
                  )
                ))}
              </div>
            )}
            {projectData?.["styleframes-breakdown"]?.["top-text"] && (
              <div class="breakdown-text">
                <h2 class="breakdown-title">{projectData["styleframes-breakdown"]["top-text"].title}</h2>
                <div class="breakdown-content">
                  {
                    projectData["styleframes-breakdown"]["top-text"].content.map((paragraph) => (
                      <p class="breakdown-paragraph">{paragraph}</p>
                    ))
                  }
                </div>
              </div>
            )}
          </div>
          
          <!-- Bottom: Flex Column Layout -->
          {projectData?.["styleframes-breakdown"]?.["layout-images"] && projectData["styleframes-breakdown"]["layout-images"].length >= 4 && (
            <div class="breakdown-layout">
              <!-- Row 1: Two images (Matched Height) -->
              <div class="breakdown-row-top">
                <div class="breakdown-item-large">
                  <img 
                    src={projectData["styleframes-breakdown"]["layout-images"][0].src} 
                    alt={projectData["styleframes-breakdown"]["layout-images"][0].alt} 
                    class="breakdown-media" 
                  />
                </div>
                <div class="breakdown-item-tall">
                  <img 
                    src={projectData["styleframes-breakdown"]["layout-images"][1].src} 
                    alt={projectData["styleframes-breakdown"]["layout-images"][1].alt} 
                    class="breakdown-media breakdown-media-2" 
                  />
                </div>
              </div>
              
              <!-- Row 2: Full Width Video (Wireframe) or Image Fallback -->
              {/* If wireframeVideoSrc is available, use it as wireframe loop.
                  Otherwise, if videoSrc exists, use that. If neither exists,
                  fallback to layout-images[4] if it exists. */}
              {(projectData.wireframeVideoSrc || projectData.videoSrc || projectData["styleframes-breakdown"]["layout-images"][4]) && (
                <div class="breakdown-item-full">
                  {projectData.wireframeVideoSrc || projectData.videoSrc ? (
                    <video
                      src={projectData.wireframeVideoSrc ? resolvedWireframeVideoSrc : resolvedVideoSrc}
                      class="breakdown-media"
                      autoplay
                      loop
                      muted
                      playsinline
                      preload="metadata"
                      style="object-fit: cover;"
                      oncontextmenu="return false;"
                    ></video>
                  ) : (
                    projectData["styleframes-breakdown"]["layout-images"][4].src.startsWith("/") ? (
                      <img 
                        src={projectData["styleframes-breakdown"]["layout-images"][4].src} 
                        alt={projectData["styleframes-breakdown"]["layout-images"][4].alt} 
                        class="breakdown-media" 
                      />
                    ) : (
                      <CldImage
                        src={projectData["styleframes-breakdown"]["layout-images"][4].src}
                        alt={projectData["styleframes-breakdown"]["layout-images"][4].alt}
                        class="breakdown-media"
                      />
                    )
                  )}
                </div>
              )}
              
              <!-- Row 3: Two equal side-by-side images -->
              <div class="breakdown-row-bottom">
                <div class="breakdown-item-half">
                  <img 
                    src={projectData["styleframes-breakdown"]["layout-images"][2].src} 
                    alt={projectData["styleframes-breakdown"]["layout-images"][2].alt} 
                    class="breakdown-media" 
                  />
                </div>
                <div class="breakdown-item-half">
                  <img 
                    src={projectData["styleframes-breakdown"]["layout-images"][3].src} 
                    alt={projectData["styleframes-breakdown"]["layout-images"][3].alt} 
                    class="breakdown-media" 
                  />
                </div>
              </div>
            </div>
          )}

          {projectData?.["styleframes-breakdown"]?.["layout-images-2"] && projectData["styleframes-breakdown"]["layout-images-2"].length >= 4 && (
            <div class="breakdown-layout">
              <!-- Row 1: Two images (Matched Height) -->
              <div class="breakdown-row-top">
                <div class="breakdown-item-large">
                  <img 
                    src={projectData["styleframes-breakdown"]["layout-images-2"][0].src} 
                    alt={projectData["styleframes-breakdown"]["layout-images-2"][0].alt} 
                    class="breakdown-media" 
                  />
                </div>
                <div class="breakdown-item-tall">
                  <img 
                    src={projectData["styleframes-breakdown"]["layout-images-2"][1].src} 
                    alt={projectData["styleframes-breakdown"]["layout-images-2"][1].alt} 
                    class="breakdown-media breakdown-media-2" 
                  />
                </div>
              </div>
              
              <!-- Row 2: Full Width Video (Wireframe) or Image Fallback -->
              {(projectData.wireframeVideoSrc2 || projectData["styleframes-breakdown"]["layout-images-2"][4]) && (
                <div class="breakdown-item-full">
                  {projectData.wireframeVideoSrc2 ? (
                    <video
                      src={resolvedWireframeVideoSrc2}
                      class="breakdown-media"
                      autoplay
                      loop
                      muted
                      playsinline
                      preload="metadata"
                      style="object-fit: cover;"
                      oncontextmenu="return false;"
                    ></video>
                  ) : (
                    projectData["styleframes-breakdown"]["layout-images-2"][4].src.startsWith("/") ? (
                      <img 
                        src={projectData["styleframes-breakdown"]["layout-images-2"][4].src} 
                        alt={projectData["styleframes-breakdown"]["layout-images-2"][4].alt} 
                        class="breakdown-media" 
                      />
                    ) : (
                      <CldImage
                        src={projectData["styleframes-breakdown"]["layout-images-2"][4].src}
                        alt={projectData["styleframes-breakdown"]["layout-images-2"][4].alt}
                        class="breakdown-media" 
                      />
                    )
                  )}
                </div>
              )}
              
              <!-- Row 3: Two equal side-by-side images -->
              <div class="breakdown-row-bottom">
                <div class="breakdown-item-half">
                  {!projectData["styleframes-breakdown"]["layout-images-2"][2].src.startsWith("/") && !projectData["styleframes-breakdown"]["layout-images-2"][2].src.includes(".") ? (
                    <video
                      src={`https://res.cloudinary.com/${cloudName}/video/upload/f_auto,q_auto/${projectData["styleframes-breakdown"]["layout-images-2"][2].src}.mp4`}
                      class="breakdown-media"
                      autoplay
                      loop
                      muted
                      playsinline
                      style="object-fit: cover;"
                      oncontextmenu="return false;"
                      disablepictureinpicture
                      disableRemotePlayback
                    ></video>
                  ) : projectData["styleframes-breakdown"]["layout-images-2"][2].src.startsWith("/") ? (
                    <img 
                      src={projectData["styleframes-breakdown"]["layout-images-2"][2].src} 
                      alt={projectData["styleframes-breakdown"]["layout-images-2"][2].alt} 
                      class="breakdown-media" 
                    />
                  ) : (
                    <CldImage
                      src={projectData["styleframes-breakdown"]["layout-images-2"][2].src}
                      alt={projectData["styleframes-breakdown"]["layout-images-2"][2].alt}
                      class="breakdown-media"
                    />
                  )}
                </div>
                <div class="breakdown-item-half">
                  {!projectData["styleframes-breakdown"]["layout-images-2"][3].src.startsWith("/") && !projectData["styleframes-breakdown"]["layout-images-2"][3].src.includes(".") ? (
                    <video
                      src={`https://res.cloudinary.com/${cloudName}/video/upload/f_auto,q_auto/${projectData["styleframes-breakdown"]["layout-images-2"][3].src}.mp4`}
                      class="breakdown-media"
                      autoplay
                      loop
                      muted
                      playsinline
                      style="object-fit: cover;"
                      oncontextmenu="return false;"
                      disablepictureinpicture
                      disableRemotePlayback
                    ></video>
                  ) : projectData["styleframes-breakdown"]["layout-images-2"][3].src.startsWith("/") ? (
                    <img 
                      src={projectData["styleframes-breakdown"]["layout-images-2"][3].src} 
                      alt={projectData["styleframes-breakdown"]["layout-images-2"][3].alt} 
                      class="breakdown-media" 
                    />
                  ) : (
                    <CldImage
                      src={projectData["styleframes-breakdown"]["layout-images-2"][3].src}
                      alt={projectData["styleframes-breakdown"]["layout-images-2"][3].alt}
                      class="breakdown-media"
                    />
                  )}
                </div>
              </div>
            </div>
          )}
        </div>
      )}
    </section>
  )}

  <!-- CHALLENGE SECTION -->
  {(projectData?.["motion-process-title"] || (projectData?.["motion-process-images-sets"]?.set1 && projectData["motion-process-images-sets"].set1.length > 0) || projectData?.["motion-text-block-1"]) && (
    <section class="process-section motion-process-section">
      <div class="process-container">
        <!-- Header -->
        {(projectData?.["motion-process-title"] || projectData?.["motion-process-par"]) && (
          <div class="process-header">
            <h2 class="process-title">{projectData?.["motion-process-title"]}</h2>
            <div class="process-description">
              <p set:html={projectData?.["motion-process-par"] || "Add motion process description"} />
            </div>
          </div>
        )}

        <!-- Decorative Lines with Image Containers -->
        <div class="decorative-lines">
          <svg
            class="grid-lines-svg"
            preserveAspectRatio="none"
            viewBox="0 0 1512 400"
            xmlns="http://www.w3.org/2000/svg"
          >
            <!-- Lines will be generated by JavaScript -->
          </svg>

          <!-- Image Container Overlay -->
          <div class="sketch-container-wrapper">
            <div class="sketch-container-grid">
              <!-- Row 1: Dynamic Design Process Grid -->
              <div class={`design-sketch-grid layout-${(projectData?.["motion-process-images-sets"]?.set1 || []).length}`} id={project === "faramove-campaign" ? "faramove-campaign-motion-grid" : undefined}>
                {(projectData?.["motion-process-images-sets"]?.set1 || []).map((img) => (
                  <div class={`sketch-container dynamic-sketch-item ${img.src === "/GIF/OPSIN/OPS-text-wired-full-frame.gif" ? "opsin-wired-container" : ""}`}>
                    {!img.src.startsWith("/") && !img.src.includes(".") ? (
                      <video
                        src={`https://res.cloudinary.com/${cloudName}/video/upload/f_auto,q_auto/${img.src}.mp4`}
                        class="sketch-image"
                        autoplay
                        loop
                        muted
                        playsinline
                        style="object-fit: cover;"
                        oncontextmenu="return false;"
                      ></video>
                    ) : img.src.startsWith("/") ? (
                      <img
                        src={img.src}
                        alt={img.alt || "Motion process sketch"}
                        class={`sketch-image ${img.src === "/GIF/farmove-pointer-parcel-pickup-loop.gif" ? "pointer-parcel-image" : ""} ${img.src === "/png/faramove-box-unwrapped.png" ? "box-unwrapped-image" : ""} ${img.src === "/GIF/OPSIN/OPS-text-wired-full-frame.gif" ? "opsin-wired-text-image" : ""}`}
                      />
                    ) : (
                      <CldImage
                        src={img.src}
                        alt={img.alt || "Motion process sketch"}
                        class={`sketch-image ${img.src === "/GIF/farmove-pointer-parcel-pickup-loop.gif" ? "pointer-parcel-image" : ""} ${img.src === "/png/faramove-box-unwrapped.png" ? "box-unwrapped-image" : ""} ${img.src === "/GIF/OPSIN/OPS-text-wired-full-frame.gif" ? "opsin-wired-text-image" : ""}`}
                      />
                    )}
                  </div>
                ))}
                  </div>

              <!-- Row 2: Text Blocks - Equal Width -->
              <div class="sketch-container text-block-1">
                    <div class="text-content">
                  <p
                    set:html={projectData?.["motion-text-block-1"] || "Add motion text 1"}
                  />
                    </div>
                  </div>

              <div class="sketch-container text-block-2">
                <div class="text-content">
                  <p
                    set:html={projectData?.["motion-text-block-2"] || "Add motion text 2"}
                  />
                </div>
              </div>

              <!-- Row 3: Full Width Text Block -->
              <div class="sketch-container text-block-full">
                <!-- Challenge Section -->
                <div class="challenge-section">
                  <div class="challenge-badge">
                    <p class="challenge-label">challenge</p>
                    <p class="challenge-number">{projectData.project === 'pinata-audio' ? 'ONE' : 'TWO'}</p>
                  </div>
                <h2 class="challenge-title">{projectData?.["motion-challenge-title"]}</h2>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Full-width GIF Banner -->
        <div class="motion-divider-banner" data-banner-src={projectData?.["motion-process-images-sets"]?.banner}></div>

        {(projectData?.["motion-process-images-sets"]?.set2 && projectData["motion-process-images-sets"].set2.length > 0) || projectData?.["motion-text-block-3"] || projectData?.["motion-text-block-4"] ? (
        <div class="decorative-lines">
          <svg
            class="grid-lines-svg"
            preserveAspectRatio="none"
            viewBox="0 0 1512 400"
            xmlns="http://www.w3.org/2000/svg"
          >
            <!-- Lines will be generated by JavaScript -->
          </svg>

          <!-- Image Container Overlay -->
          <div class="sketch-container-wrapper">
              <div class="sketch-container-grid">
                <!-- Row 1: Dynamic Design Process Grid -->
                <div class={`design-sketch-grid layout-${(projectData?.["motion-process-images-sets"]?.set2 || []).length}`}>
                  {(projectData?.["motion-process-images-sets"]?.set2 || []).map((img) => (
                    <div class="sketch-container dynamic-sketch-item">
                      {!img.src.startsWith("/") && !img.src.includes(".") ? (
                        <video
                          src={`https://res.cloudinary.com/${cloudName}/video/upload/f_auto,q_auto/${img.src}.mp4`}
                          class="sketch-image"
                          autoplay
                          loop
                          muted
                          playsinline
                          style="object-fit: cover;"
                        ></video>
                      ) : img.src.startsWith("/") ? (
                        <img
                          src={img.src}
                          alt={img.alt || "Motion process sketch"}
                          class={`sketch-image ${img.src === "/GIF/farmove-pointer-ariel-loop.gif" ? "pointer-ariel-image" : ""} ${img.src === "/GIF/farmove-arrow-loop-wide.gif" ? "arrow-loop-image" : ""}`}
                        />
                      ) : (
                        <CldImage
                          src={img.src}
                          alt={img.alt || "Motion process sketch"}
                          class={`sketch-image ${img.src === "/GIF/farmove-pointer-ariel-loop.gif" ? "pointer-ariel-image" : ""} ${img.src === "/GIF/farmove-arrow-loop-wide.gif" ? "arrow-loop-image" : ""}`}
                        />
                      )}
                    </div>
                  ))}
                  </div>
            
              <!-- Row 2: Text Blocks - Equal Width -->
              <div class="sketch-container text-block-1">
                <div class="text-content">
                  <p
                    set:html={projectData?.["motion-text-block-3"] || "Add motion text 3"}
                  />
                </div>
            </div>

              <div class="sketch-container text-block-2">
                <div class="text-content">
                  <p
                    set:html={projectData?.["motion-text-block-4"] || "Add motion text 4"}
                  />
                </div>
              </div>
            </div>
          </div>
        </div>
        ) : null}
      </div>
    </section>
  )}

  <!-- SPEED LINES SECTION -->
  {projectData?.["sound-design"] && (
    <section class="sound-design-section">
      <div class="sound-design-container">
        <!-- Top: Full Width Image -->
        {projectData["sound-design"]["main-image"] && (
          <div class="sound-design-top">
            <img src={projectData["sound-design"]["main-image"]} alt={projectData["sound-design"].title} />
          </div>
        )}
        
        <!-- Bottom: Split Layout -->
        <div class="sound-design-bottom">
          <!-- Left: Image + Caption -->
          {(projectData["sound-design"]["channel-image"] || projectData["sound-design"]["audio-caption"]) && (
            <div class="sound-bottom-left">
              {projectData["sound-design"]["channel-image"] && (
                <div class="sound-channel-image">
                  <img src={projectData["sound-design"]["channel-image"]} alt="Audio Channel" />
                </div>
              )}
              {projectData["sound-design"]["audio-caption"] && (
                <p class="sound-caption">
                  {projectData["sound-design"]["audio-caption"]}
                </p>
              )}
            </div>
          )}
          
          <!-- Right: Text Content -->
          <div class="sound-bottom-right">
            <h2 class="sound-title">{projectData["sound-design"].title}</h2>
            <p class="sound-description">
              {projectData["sound-design"].description}
            </p>
          </div>
        </div>
      </div>
    </section>
  )}

  <!-- CREDITS SECTION -->
  {projectData?.credits && (
    <section class={`credits-section ${!projectData?.["sound-design"] ? "no-sound-design" : ""}`}>
      <div class="credits-container">
        <div class="credits-list">
          {projectData.credits.map((credit) => (
            <div class="credit-item">
              <p class="credit-role">{credit.role}</p>
              <p class="credit-name">{credit.name}</p>
            </div>
          ))}
        </div>
        
        <div class="credits-right">
          <div class="credits-header">
            <h2 class="credits-title">credits</h2>
            <p class="credits-subtitle">priviledged to work with some of the most talented people existing.</p>
          </div>

          <div class="more-cc-container">
            {projectData.moreCredits && (
              <div class="more-credits-list">
                {projectData.moreCredits.map((credit) => (
                  <div class="more-credit-item">
                    <span class="more-credit-role">{credit.role}</span>
                    <span class="more-credit-entity">{credit.entity}</span>
                  </div>
                ))}
              </div>
            )}
            
            <button class="more-cc-button" aria-expanded="false">
              <span class="cc-link-text">more cc</span>
              <div class="cc-arrow">
                
<svg xmlns="http://www.w3.org/2000/svg" width="12" height="10" fill="none"><path fill="#F72F2F" d="m5.774 0 5.773 10H0L5.774 0Z"/></svg>
              </div>
            </button>
          </div>
        </div>
      </div>
    </section>
  )}

  <Footer />

<script>
  // @ts-check
  import Smooothy from "smooothy";
  import { gsap } from "gsap";
  import { ScrollTrigger } from "gsap/ScrollTrigger";

  // Register GSAP plugins
  gsap.registerPlugin(ScrollTrigger);

  // GSAP Parallax Effect - Hero Content Wrapper
  const heroContentWrapper = document.querySelector(".hero-content-wrapper");
  const videoSection = document.querySelector(".video-section");
  const scrollContainer = document.querySelector(".scroll-container");

  // Use GSAP matchMedia for responsive animations
  let mm = gsap.matchMedia();

  // Desktop animations only (min-width: 901px)
  mm.add("(min-width: 901px)", () => {
  if (heroContentWrapper && videoSection) {
    // Ease-out for fast start, slow end when scrolling back
    const easeOut = "power2.out"; // Fast start, slow end - perfect for scroll back

    // Calculate distance based on viewport height (since hero is 80vh)
    // Move it by 100vh to ensure it's completely out of view
    const moveDistance = -(window.innerHeight * 0.15); // Move by full viewport height

    console.log("Hero move distance:", moveDistance, "vh");

    // Move up animation with ease-out and depth effect - responsive when scrolling back
    gsap.to(heroContentWrapper, {
      y: moveDistance,
      scale: 0.85, // Slight scale down for depth as it moves away
      ease: easeOut,
      scrollTrigger: {
        trigger: ".video-section",
        start: "top bottom-=300", // Start even earlier (200px before main sketch)
        end: "center center", // End when center of process section hits center of viewport (halfway through)
        scrub: 0.2, // Faster response for quicker return when scrolling back
        markers: false,
      },
    });

    // Enhanced fade out with custom ease
    gsap.to(heroContentWrapper, {
      opacity: 0,
      ease: "power3.out", // More dramatic ease curve
      scrollTrigger: {
        trigger: ".hero-section",
        start: "center top", // Starts later - when center of hero hits top
        end: () => `+=${(videoSection as HTMLElement).offsetTop}`, // Match the movement end
        scrub: 0, // Slightly slower for smoother fade
        markers: false,
      },
    });
  }

  // GSAP Snap Scrolling for Video Section
  if (scrollContainer && videoSection) {
    // Use ScrollTrigger.scrollerProxy for custom scroll container
    ScrollTrigger.scrollerProxy(scrollContainer, {
      scrollTop(value?: number) {
        if (arguments.length && value !== undefined) {
          scrollContainer.scrollTop = value;
        }
        return scrollContainer.scrollTop;
      },
      getBoundingClientRect() {
        return {
          top: 0,
          left: 0,
          width: window.innerWidth,
          height: window.innerHeight,
        };
      },
    });

    // Create snap point at video section
    ScrollTrigger.create({
      trigger: ".video-section",
      scroller: scrollContainer,
      start: "top 60%",
      end: "top 40%",
      onEnter: () => {
        gsap.to(scrollContainer, {
          scrollTop: (videoSection as HTMLElement).offsetTop,
          duration: 0.8,
          ease: "power2.inOut",
          overwrite: true,
          
        });
      },
      onEnterBack: () => {
        gsap.to(scrollContainer, {
          scrollTop:
            (videoSection as HTMLElement).offsetTop - window.innerHeight,
          duration: 0.8,
          ease: "power2.inOut",
          overwrite: true,
        });
      },
      markers: false,
    });

    // Refresh ScrollTrigger after setup
    ScrollTrigger.refresh();
  }
  });


  // Process sections parallax animations - loop through all sections
  const processSections = document.querySelectorAll(".process-section");

  processSections.forEach((section) => {
    // Main Sketch parallax animation
    const mainSketch = section.querySelector(".main-sketch");

    if (mainSketch) {
      gsap.from(mainSketch, {
        y: -350, // Move down 350px as you scroll
        scrollTrigger: {
          trigger: section, // Trigger when this specific process section enters viewport
          start: "top bottom", // Start when top of process section hits bottom of viewport
          end: "center center", // End when center of process section hits center of viewport (halfway through)
          scrub: 1, // Smooth parallax effect tied to scroll
          markers: false,
        },
      });
    }

    // Mobile Sketch containers - reverse movement with offset
    const mobileSketch1 = section.querySelector(".mobile-sketch-1");
    const mobileSketch2 = section.querySelector(".mobile-sketch-2");

    if (mobileSketch1) {
      gsap.from(mobileSketch1, {
        y: 350, // Start below and move up (reverse of main sketch)
        scrollTrigger: {
          trigger: section, // Trigger when this specific process section enters viewport
          start: "top bottom-=100", // Start earlier (100px before main sketch)
          end: "center center", // End when center of process section hits center of viewport (halfway through)
          scrub: 1, // Smooth parallax effect tied to scroll
          markers: false,
        },
      });
    }

    if (mobileSketch2) {
      gsap.from(mobileSketch2, {
        y: 350, // Start below and move up (reverse of main sketch)
        scrollTrigger: {
          trigger: section, // Trigger when this specific process section enters viewport
          start: "top bottom-=500", // Start even earlier (200px before main sketch)
          end: "center center", // End when center of process section hits center of viewport (halfway through)
          scrub: 1, // Smooth parallax effect tied to scroll
          markers: false,
        },
      });
    }
  });

  // Initialize Swiper Hero Carousel
  const heroCarousel = document.getElementById("hero-carousel") as HTMLElement;

  // Gallery Modal Functionality
  const modal = document.getElementById("video-modal");
  const modalVideo = document.getElementById(
    "modal-video-player"
  ) as HTMLVideoElement;
  const modalVideoSource = document.getElementById(
    "modal-video-source"
  ) as HTMLSourceElement;
  const modalClose = document.getElementById("modal-close");
  const galleryItems = document.querySelectorAll(".gallery-item");

  // Open modal with video
  function openModal(videoUrl: string) {
    if (modal && modalVideo && modalVideoSource) {
      modalVideoSource.src = videoUrl;
      modalVideo.load();
      modal.classList.add("active");
      document.body.style.overflow = "hidden"; // Prevent background scrolling
    }
  }

  // Close modal
  function closeModal() {
    if (modal && modalVideo) {
      modal.classList.remove("active");
      modalVideo.pause();
      modalVideo.currentTime = 0;
      document.body.style.overflow = ""; // Re-enable scrolling
    }
  }

  // Add click handlers to gallery items
  galleryItems.forEach((item) => {
    item.addEventListener("click", () => {
      const videoUrl = item.getAttribute("data-video");
      if (videoUrl) {
        openModal(videoUrl);
      }
    });
  });

  // Close modal on close button click
  modalClose?.addEventListener("click", closeModal);

  // Close modal on outside click
  modal?.addEventListener("click", (e) => {
    if (e.target === modal) {
      closeModal();
    }
  });

  // Close modal on Escape key
  document.addEventListener("keydown", (e) => {
    if (e.key === "Escape" && modal?.classList.contains("active")) {
      closeModal();
    }
  });

  // Pause marquee on hover
  const marqueeContent = document.querySelector(
    ".marquee-content"
  ) as HTMLElement;
  const marqueeContainer = document.querySelector(".marquee-container");

  marqueeContainer?.addEventListener("mouseenter", () => {
    if (marqueeContent) {
      marqueeContent.style.animationPlayState = "paused";
    }
  });

  marqueeContainer?.addEventListener("mouseleave", () => {
    if (marqueeContent) {
      marqueeContent.style.animationPlayState = "running";
    }
  });

  // SVG Grid Lines Generator
  function generateGridLines() {
    const svgs = document.querySelectorAll(
      ".grid-lines-svg"
    ) as NodeListOf<SVGElement>;
    if (!svgs || svgs.length === 0) return;

    // Generate lines for each SVG element
    svgs.forEach((svg) => {
      const container = svg.parentElement;
      if (!container) return;

      // Configuration
      const config = {
        lineSpacing: 22, // Spacing between lines in pixels
        topSegmentStart: 0.24, // 333.508 / 1395  0.24
        topSegmentEnd: 0.434, // 605.368 / 1395  0.434
        middleSegmentEnd: 0.706, // 985.368 / 1395  0.706
        bottomSegmentEnd: 0.901, // 1257.23 / 1395  0.901
        thickStrokeWidth: 9,
        thinStrokeWidth: 1,
        strokeColor: "#ACAAA3",
        startOffset: 5, // Minimal offset to prevent cut-off
      };

      // Clear existing lines
      svg.innerHTML = "";

      // Calculate container width and number of lines
      const containerWidth = container.offsetWidth;

      // Use full container width for viewBox
      svg.setAttribute("viewBox", `0 0 ${containerWidth} 400`);

      // Calculate available width for lines (account for left/right padding of overlay grid)
      let horizontalPadding = 0;
      const overlayGridForPadding = container.querySelector(
        ".sketch-container-grid"
      ) as HTMLElement | null;
      if (overlayGridForPadding) {
        const cs2 = getComputedStyle(overlayGridForPadding);
        const padLeft = parseFloat(cs2.paddingLeft || "0");
        const padRight = parseFloat(cs2.paddingRight || "0");
        horizontalPadding = padLeft + padRight;
      }
      const availableWidth =
        containerWidth - horizontalPadding - config.startOffset * 2;

      // Keep constant spacing but distribute leftover equally on both sides
      const spacing = config.lineSpacing;
      const numLines = Math.floor(availableWidth / spacing) + 1; // number of lines so last index fits in width
      const spanWidth = (numLines - 1) * spacing; // distance from first to last line
      const sideRemainder = Math.max(availableWidth - spanWidth, 0);
      const sidePadding = sideRemainder / 2; // equal gap on left and right inside overlay padding

      // Start position: left overlay padding + inner offset + equalized side padding
      const leftOverlayPadding = overlayGridForPadding
        ? parseFloat(getComputedStyle(overlayGridForPadding).paddingLeft || "0")
        : 0;
      const adjustedStartOffset =
        leftOverlayPadding + config.startOffset + sidePadding;

      // Get the actual SVG height from viewBox or container
      const svgHeight = (svg as any).viewBox.baseVal.height || 400;

      // Read top/bottom padding from the overlay grid so thick segments can form a border
      let topPaddingPx = 0;
      let bottomPaddingPx = 0;
      const overlayGrid = container.querySelector(
        ".sketch-container-grid"
      ) as HTMLElement | null;
      if (overlayGrid) {
        const cs = getComputedStyle(overlayGrid);
        topPaddingPx = parseFloat(cs.paddingTop || "0");
        bottomPaddingPx = parseFloat(cs.paddingBottom || "0");
      }

      // Generate lines
      for (let i = 0; i < numLines; i++) {
        const x = adjustedStartOffset + i * spacing;
        const groupIndex = Math.floor(i / 5); // Group every 5 lines for future animation

        // Create group for this line (for future animation control)
        const group = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "g"
        );
        group.classList.add("grid-line-group");
        group.setAttribute("data-group", groupIndex.toString());
        group.setAttribute("data-line", i.toString());

        // Top segment (thick stroke) - from very top to the start of the middle (acts like border)
        const topLine = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "path"
        );
        topLine.setAttribute("d", `M${x} ${topPaddingPx}V0`);
        topLine.setAttribute("stroke", config.strokeColor);
        topLine.setAttribute(
          "stroke-width",
          config.thickStrokeWidth.toString()
        );
        topLine.classList.add("grid-line-top");
        group.appendChild(topLine);

        // Middle segment (thin stroke) - spans the grid area between paddings
        const middleLine = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "path"
        );
        middleLine.setAttribute(
          "d",
          `M${x} ${topPaddingPx}V${svgHeight - bottomPaddingPx}`
        );
        middleLine.setAttribute("stroke", config.strokeColor);
        middleLine.setAttribute(
          "stroke-width",
          config.thinStrokeWidth.toString()
        );
        middleLine.classList.add("grid-line-middle");
        group.appendChild(middleLine);

        // Bottom segment (thick stroke) - from end of middle to very bottom (acts like border)
        const bottomLine = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "path"
        );
        bottomLine.setAttribute(
          "d",
          `M${x} ${svgHeight}V${svgHeight - bottomPaddingPx}`
        );
        bottomLine.setAttribute("stroke", config.strokeColor);
        bottomLine.setAttribute(
          "stroke-width",
          config.thickStrokeWidth.toString()
        );
        bottomLine.classList.add("grid-line-bottom");
        group.appendChild(bottomLine);

        svg.appendChild(group);
      }
    }); // End forEach loop for each SVG
  }

  // Update SVG height based on container grid height
  function updateSVGHeight() {
    const processSections = document.querySelectorAll(".process-section");

    processSections.forEach((section) => {
      const svg = section.querySelector(".grid-lines-svg") as SVGElement;
      const containerWrapper = section.querySelector(
        ".sketch-container-wrapper"
      ) as HTMLElement;
      const decorativeLines = section.querySelector(
        ".decorative-lines"
      ) as HTMLElement;

      if (!svg || !containerWrapper || !decorativeLines) return;

      // Get the actual height of the container wrapper
      const gridHeight = containerWrapper.offsetHeight;

      // Update decorative-lines container height
      decorativeLines.style.height = `${gridHeight}px`;

      // Get current viewBox
      const viewBox = svg.getAttribute("viewBox");
      if (!viewBox) return;

      const [x, y, width] = viewBox.split(" ").map(Number);

      // Update viewBox height to match grid height
      svg.setAttribute("viewBox", `${x} ${y} ${width} ${gridHeight}`);
    });

    // Regenerate lines with new height for all sections
    generateGridLines();
  }

  // Call after grid generation and on resize
  window.addEventListener("DOMContentLoaded", () => {
    setTimeout(() => {
      generateGridLines();
      updateSVGHeight();
    }, 100);
  });

  // Also try to initialize immediately if DOM is already loaded
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", () => {
      setTimeout(() => {
        generateGridLines();
        updateSVGHeight();
      }, 100);
    });
  } else {
    setTimeout(() => {
      generateGridLines();
      updateSVGHeight();
    }, 100);
  }

  // Update on resize
  let resizeTimeout: ReturnType<typeof setTimeout>;
  window.addEventListener("resize", () => {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
      updateSVGHeight();
      // Force Smooothy to recalculate viewport on resize with 1512px constraint
      if (typeof heroCarouselInstance !== "undefined") {
        heroCarouselInstance.resize();
        // Force viewport constraint after resize
        if (
          heroCarouselInstance.viewport &&
          heroCarouselInstance.viewport.wrapperWidth > 1512
        ) {
          heroCarouselInstance.viewport.wrapperWidth = 1512;
        }
      }
      if (typeof thumbsCarousel !== "undefined") {
        thumbsCarousel.resize();
        // Force viewport constraint after resize
        if (
          thumbsCarousel.viewport &&
          thumbsCarousel.viewport.wrapperWidth > 1512
        ) {
          console.log("Styleframes carousel - forcing viewport to 1512px");
          thumbsCarousel.viewport.wrapperWidth = 1512;
        }
      }
    }, 250);
  });

  // ==================== HERO CAROUSEL WITH SMOOOTHY ====================
  const heroCarouselElement = document.getElementById(
    "hero-carousel"
  ) as HTMLElement;
  let heroCarouselInstance: any;

  // Check if the hero carousel actually exists (might be replaced by marquee banner)
  if (heroCarouselElement) {
    console.log("Hero carousel found:", heroCarouselElement);

    // Initialize Smooothy for hero carousel
    heroCarouselInstance = new Smooothy(heroCarouselElement, {
      infinite: true,
      snap: false,
      dragSensitivity: 0.019,
      lerpFactor: 0.35,
      scrollInput: true,
      onUpdate: (instance) => {
        // Force viewport to think we're on a 1512px screen
        if (instance.viewport && instance.viewport.wrapperWidth > 1512) {
          instance.viewport.wrapperWidth = 1512;
        }
      },
    });

    // Auto-scroll functionality for hero carousel
    let heroAutoScrollSpeed = -0.003; // Slower speed for hero carousel
    let heroIsPaused = false;

    // Pause on hover for hero carousel
    heroCarouselElement.addEventListener("mouseenter", () => {
      heroIsPaused = true;
    });

    heroCarouselElement.addEventListener("mouseleave", () => {
      heroIsPaused = false;
    });

    // Animation loop for hero carousel auto-scroll using GSAP ticker
    function updateHero() {
      if (!heroIsPaused) {
        heroCarouselInstance.target += heroAutoScrollSpeed;
      }
    }

    // Use GSAP ticker for smooth updates
    gsap.ticker.add(updateHero);
    gsap.ticker.add(heroCarouselInstance.update.bind(heroCarouselInstance));
  } else {
    console.log("Hero carousel not found in DOM (likely replaced by custom banner)");
  }

  // ==================== STYLEFRAMES THUMBS WITH SMOOOTHY ====================
  // Find the second carousel (styleframes thumbs) - it's the second .carousel-wrapper
  const carouselWrappers = document.querySelectorAll(".carousel-wrapper");
  const thumbsRail = carouselWrappers[1] as HTMLElement; // Second carousel is the thumbs rail
  let thumbsCarousel: any;

  console.log("Total carousel wrappers found:", carouselWrappers.length);
  console.log("First carousel (hero):", carouselWrappers[0]);
  console.log("Second carousel (thumbs):", carouselWrappers[1]);

  // Get styleframeSet from data attribute
  const previewContainer = document.querySelector(
    ".styleframes-preview"
  ) as HTMLElement;
  const styleframeSet = previewContainer
    ? JSON.parse(previewContainer.getAttribute("data-styleframes") || "[]")
    : [];

  if (thumbsRail) {
    console.log("Thumbs rail found:", thumbsRail);

    // Initialize Smooothy for thumbs rail - DRAG ONLY, NO AUTO-SCROLL
    thumbsCarousel = new Smooothy(thumbsRail, {
      infinite: false, // No infinite loop - this naturally prevents over-scrolling
      snap: true, // Enable snapping for smooth drag-to-stop behavior
      dragSensitivity: 0.019, // Same drag sensitivity as hero
      lerpFactor: 0.35, // Same lerp factor as hero
      scrollInput: true,
      onUpdate: (instance) => {
        // Force viewport to think we're on a 1512px screen
        if (instance.viewport && instance.viewport.wrapperWidth > 1512) {
          console.log("Forcing viewport to 1512px");
          instance.viewport.wrapperWidth = 1512;
        }
        // Let Smooothy handle bounds naturally with infinite: false
      },
    });

    // NO auto-scroll functionality - drag only
    // But we still need GSAP ticker for drag animations
    gsap.ticker.add(thumbsCarousel.update.bind(thumbsCarousel));
    console.log("Styleframes carousel initialized - drag only, no auto-scroll");

    // ==================== DYNAMIC PREVIEW IMAGE SYSTEM ====================
    // Get all carousel items and preview image
    const carouselItems = thumbsRail.querySelectorAll(".carousel-item-inner");
    const previewImage = document.getElementById(
      "current-styleframe"
    ) as HTMLImageElement;
    const detector = document.getElementById("styleframe-detector");
    const counterNumber = document.querySelector(
      ".counter-number.current"
    ) as HTMLElement;

    function updatePreviewImage() {
      if (!detector || !previewImage) return;

      const detectorRect = detector.getBoundingClientRect();
      const detectorLeft = detectorRect.left;
      const detectorRight = detectorRect.right;

      carouselItems.forEach((item, index) => {
        const rect = item.getBoundingClientRect();
        const centerX = (rect.left + rect.right) / 2;

        // Check if item center intersects with detector
        if (centerX >= detectorLeft && centerX <= detectorRight) {
          // Get the image from this carousel item
          const carouselImage = item.querySelector(
            ".carousel-image2"
          ) as HTMLImageElement;
          if (carouselImage && carouselImage.src) {
            (previewImage as HTMLImageElement).src = carouselImage.src;
            (previewImage as HTMLImageElement).alt =
              carouselImage.alt || "Current Styleframe";

            // Update the counter to show current item number (1-based)
            if (counterNumber) {
              counterNumber.textContent = (index + 1).toString();
            }

            console.log(
              "Preview updated with:",
              carouselImage.src,
              "Counter:",
              index + 1
            );
          }
        }
      });
    }

    // Update on scroll/drag
    gsap.ticker.add(updatePreviewImage);

    // Initial update
    updatePreviewImage();
  } else {
    console.error("Thumbs rail (second carousel) not found in DOM");
  }

  // ==================== MOTION DIVIDER BANNER LOGIC ====================
  function initMotionDivider() {
    const banner = document.querySelector(".motion-divider-banner") as HTMLElement;
    if (!banner) return;

    const bannerSrc = banner.getAttribute('data-banner-src');
    // If banner src not provided, hide or return
    if (!bannerSrc) {
        banner.style.display = 'none';
        return;
    }

    // Helper to populate banner
    const populateBanner = () => {
      // Clear existing content
      banner.innerHTML = "";
      
      // We need to know the aspect ratio of the image to calculate how many we need
      // Create a temporary image to load and check dimensions
      const tempImg = new Image();
      tempImg.src = bannerSrc;
      
      tempImg.onload = () => {
        const imgWidth = tempImg.naturalWidth;
        const imgHeight = tempImg.naturalHeight;
        
        // Calculate effective width after rotation (-90deg)
        // When rotated -90deg:
        // The visual width of the item becomes its original height
        // The visual height of the item becomes its original width
        
        // However, we want the items to fit the container height (150px)
        // Container Height = 150px
        // So the Rotated Item Height (Visual Height) must be 150px.
        // Visual Height = Original Width.
        // So we need to scale the image such that Original Width = 150px.
        
        const targetHeight = 90; // Reduced height for smaller items
        const scaleRatio = targetHeight / imgWidth;
        
        // Scaled Original Height = imgHeight * scaleRatio
        // Visual Width = Scaled Original Height
        const itemVisualWidth = imgHeight * scaleRatio;
        
        // Calculate how many items needed to fill screen width
        const screenWidth = window.innerWidth;
        const count = Math.ceil(screenWidth / itemVisualWidth) + 1; // Add buffer
        
        // Create images
        const fragment = document.createDocumentFragment();
        for (let i = 0; i < count; i++) {
          // Create a wrapper div to handle layout space for rotated element
          const wrapper = document.createElement("div");
          wrapper.style.width = `${itemVisualWidth}px`;
          wrapper.style.height = `${targetHeight}px`;
          wrapper.style.display = "flex";
          wrapper.style.alignItems = "center";
          wrapper.style.justifyContent = "center";
          wrapper.style.overflow = "hidden"; // clip any overflow
          
          const img = document.createElement("img");
          img.src = bannerSrc;
          img.alt = "Motion divider";
          img.className = "motion-banner-item";
          
          // Force image dimensions to match the scale required
          // We want Original Width to be 150px (to match container height when rotated)
          // But wait, if we rotate -90, height becomes width.
          // CSS transform rotates the element but doesn't change layout flow unless we handle it.
          // The .motion-banner-item class has transform: rotate(-90deg)
          
          // If we set width: 150px on the img tag (which becomes height visually), 
          // and height: auto (which becomes width visually).
          img.style.width = `${targetHeight}px`; 
          img.style.height = "auto";
          
          // We need to ensure the rotated image is centered in the wrapper
          // wrapper is itemVisualWidth x 150
          
          wrapper.appendChild(img);
          fragment.appendChild(wrapper);
        }
        
        banner.appendChild(fragment);
      };
    };

    populateBanner();
    
    // Re-populate on resize (debounce)
    let resizeTimeout: ReturnType<typeof setTimeout>;
    window.addEventListener("resize", () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(populateBanner, 250);
    });
  }

  // Initialize motion divider
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initMotionDivider);
  } else {
    initMotionDivider();
  }

  // ==================== READ MORE TOGGLE ====================
  const readMoreButton = document.querySelector(".read-more-button");
  const heroDescriptionWrapper = document.querySelector(".hero-description-wrapper");

  if (readMoreButton && heroDescriptionWrapper) {
    readMoreButton.addEventListener("click", () => {
      const isExpanded = heroDescriptionWrapper.classList.contains("expanded");
      
      if (isExpanded) {
        heroDescriptionWrapper.classList.remove("expanded");
        readMoreButton.textContent = "Read more";
        readMoreButton.setAttribute("aria-expanded", "false");
      } else {
        heroDescriptionWrapper.classList.add("expanded");
        readMoreButton.textContent = "Read less";
        readMoreButton.setAttribute("aria-expanded", "true");
      }
    });
  }

  // ==================== MORE CREDITS TOGGLE ====================
  const moreCCButton = document.querySelector('.more-cc-button');
  const moreCCContainer = document.querySelector('.more-cc-container');

  if (moreCCButton && moreCCContainer) {
    moreCCButton.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      const isExpanded = moreCCButton.getAttribute('aria-expanded') === 'true';
      
      // Toggle state
      moreCCButton.setAttribute('aria-expanded', (!isExpanded).toString());
      moreCCContainer.classList.toggle('active');
    });

    // Close when clicking outside
    document.addEventListener('click', (e) => {
      if (moreCCContainer.classList.contains('active') && 
          !moreCCContainer.contains(e.target as Node)) {
        moreCCButton.setAttribute('aria-expanded', 'false');
        moreCCContainer.classList.remove('active');
      }
    });
  }
</script>

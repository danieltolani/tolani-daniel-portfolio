---
import Layout from "../layouts/Layout.astro";
import "../styles/portfolio.css";

// Import all styleframes
import sf0 from "../assets/STYLEFRAMES/FRMV-TSR-SF/FRMV-TSR-SF-0.png";
import sf1 from "../assets/STYLEFRAMES/FRMV-TSR-SF/FRMV-TSR-SF-1.png";
import sf2 from "../assets/STYLEFRAMES/FRMV-TSR-SF/FRMV-TSR-SF-2.png";
import sf3 from "../assets/STYLEFRAMES/FRMV-TSR-SF/FRMV-TSR-SF-3.png";
import sf4 from "../assets/STYLEFRAMES/FRMV-TSR-SF/FRMV-TSR-SF-4.png";
import sf5 from "../assets/STYLEFRAMES/FRMV-TSR-SF/FRMV-TSR-SF-5.png";
import sf6 from "../assets/STYLEFRAMES/FRMV-TSR-SF/FRMV-TSR-SF-6.png";
import sf7 from "../assets/STYLEFRAMES/FRMV-TSR-SF/FRMV-TSR-SF-7.png";
import sf8 from "../assets/STYLEFRAMES/FRMV-TSR-SF/FRMV-TSR-SF-8.png";
import sf9 from "../assets/STYLEFRAMES/FRMV-TSR-SF/FRMV-TSR-SF-9.png";
import sf10 from "../assets/STYLEFRAMES/FRMV-TSR-SF/FRMV-TSR-SF-10.png";
import sf11 from "../assets/STYLEFRAMES/FRMV-TSR-SF/FRMV-TSR-SF-11.png";
import sf12 from "../assets/STYLEFRAMES/FRMV-TSR-SF/FRMV-TSR-SF-12.png";
import sf13 from "../assets/STYLEFRAMES/FRMV-TSR-SF/FRMV-TSR-SF-13.png";
import sf14 from "../assets/STYLEFRAMES/FRMV-TSR-SF/FRMV-TSR-SF-14.png";
import sf15 from "../assets/STYLEFRAMES/FRMV-TSR-SF/FRMV-TSR-SF-15.png";
import sf16 from "../assets/STYLEFRAMES/FRMV-TSR-SF/FRMV-TSR-SF-16.png";
import sf17 from "../assets/STYLEFRAMES/FRMV-TSR-SF/FRMV-TSR-SF-17.png";
import sf18 from "../assets/STYLEFRAMES/FRMV-TSR-SF/FRMV-TSR-SF-18.png";
import sf19 from "../assets/STYLEFRAMES/FRMV-TSR-SF/FRMV-TSR-SF-19.png";
import sf20 from "../assets/STYLEFRAMES/FRMV-TSR-SF/FRMV-TSR-SF-20.png";
import sf21 from "../assets/STYLEFRAMES/FRMV-TSR-SF/FRMV-TSR-SF-21.png";
import sf22 from "../assets/STYLEFRAMES/FRMV-TSR-SF/FRMV-TSR-SF-22.png";

// Create array of styleframes with their src
const styleframeUrls = [
	{ src: sf0.src, num: 0 },
	{ src: sf1.src, num: 1 },
	{ src: sf2.src, num: 2 },
	{ src: sf3.src, num: 3 },
	{ src: sf4.src, num: 4 },
	{ src: sf5.src, num: 5 },
	{ src: sf6.src, num: 6 },
	{ src: sf7.src, num: 7 },
	{ src: sf8.src, num: 8 },
	{ src: sf9.src, num: 9 },
	{ src: sf10.src, num: 10 },
	{ src: sf11.src, num: 11 },
	{ src: sf12.src, num: 12 },
	{ src: sf13.src, num: 13 },
	{ src: sf14.src, num: 14 },
	{ src: sf15.src, num: 15 },
	{ src: sf16.src, num: 16 },
	{ src: sf17.src, num: 17 },
	{ src: sf18.src, num: 18 },
	{ src: sf19.src, num: 19 },
	{ src: sf20.src, num: 20 },
	{ src: sf21.src, num: 21 },
	{ src: sf22.src, num: 22 }
].map(item => item.src);
---

<Layout>
	<div class="page-container scroll-container">
		<!-- Header Navigation -->
		<header class="header" id="main-header">
				<div class="header-logo">
				<p>DNX.HOME</p>
			</div>
			<nav class="nav">
				<a href="#projects">PRJT.WORK</a>
				<a href="#about">AB.ME</a>
				<a href="#contact">CT.MAIL</a>
			</nav>
		</header>

		<!-- Hero Section -->
		<main class="hero-section snap-section">
			<div class="hero-content-wrapper">
				<div class="hero-content" id="hero-card">
						<!-- Project Title & Description -->
						<div class="hero-desc">
							<div class="hero-text">
								<h1 class="hero-title">
									FARAM<span class="special-o">O</span>VE
								</h1>
								<p class="hero-description">
									When home delivery became a necessity after
								COVID-19, Faramove wanted to reassure customers
								that a smarter solution was coming. I crafted a
								teaser video that introduced the mobile app and
								built anticipation for its launch.
								</p>
							</div>

							<!-- Thumbnail Carousel -->
					<div class="carousel-wrapper" id="smoothy-carousel">
						{styleframeUrls.map((url, index) => (
							<div class="carousel-item">
								<div class="carousel-item-inner" data-image-url={url} data-image-index={index}>
									<img src={url} alt={`Styleframe ${index}`} class="carousel-image" />
									<span class="carousel-number">STY-{index}</span>
								</div>
							</div>
						))}
							</div>
						</div>

					<!-- Lightbox Modal for Expanded Images -->
					<div id="lightbox-modal" class="lightbox-modal">
						<button id="lightbox-close" class="lightbox-close" aria-label="Close">
							CLOSE
						</button>
						<div class="lightbox-content">
							<img id="lightbox-image" class="lightbox-image" src="" alt="Expanded styleframe" />
							</div>
						</div>

						<!-- Project Metadata -->
						<div class="project-metadata">
							<div class="metadata-item">
								<span class="metadata-label">YEAR</span>
								<span class="metadata-value">2023</span>
							</div>
							<div class="metadata-item">
								<span class="metadata-label">ROLE</span>
								<span class="metadata-value"
									>Sound & Motion Designer</span
								>
							</div>
							<div class="metadata-item">
								<span class="metadata-label">TOOLS</span>
								<span class="metadata-value"
									>Figma Adobe AE, PR & Illustrator</span
								>
							</div>
							<div class="metadata-item">
								<span class="metadata-label">TYPE</span>
							<span class="metadata-value">Launch Teaser</span>
							</div>
						</div>
				</div>
			</div>
		</main>

		<!-- VIDEO SECTION -->
		<section class="snap-section video-section">
			<div class="video-container">
			  <div class="video-wrapper">
				<!-- Video Player -->
				<iframe
				  id="video-player"
				  class="video-player"
				  src="https://player.vimeo.com/video/794137708?autoplay=0&loop=0&byline=0&title=0&portrait=0&controls=0"
				  frameborder="0"
				  allow="autoplay; fullscreen; picture-in-picture"
				  allowfullscreen
				  style="position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;"
				></iframe>
				
				<!-- Video Overlay (shown when video is not playing) -->
				<div id="video-overlay" class="video-overlay"></div>
			  </div>
	  
		  <!-- PLAY BUTTON -->
		  <button id="play-button" class="play-button" aria-label="Play video">
			<div class="play-button-wrapper">
			  <div class="circle"></div>
			  <p class="play-button-text">PLAY</p>
			</div>
		  </button>
	  
			  <!-- Video Controls (shown when video is playing) -->
			  <div id="video-controls" class="video-controls">
				<button
				  id="pause-button"
				  aria-label="Pause video"
				>
				  <svg fill="currentColor" viewBox="0 0 24 24">
					<path d="M6 4h4v16H6V4zm8 0h4v16h-4V4z"/>
				  </svg>
				</button>
				
				<div class="video-controls-progress">
				  <span id="current-time" class="video-controls-time">0:00</span>
				  <input
					id="progress-bar"
					type="range"
					min="0"
					max="100"
					value="0"
					class="video-progress-bar"
				  />
				  <span id="duration" class="video-controls-time">0:00</span>
				</div>

				<button
				  id="mute-button"
				  aria-label="Mute/Unmute"
				>
				  <svg fill="currentColor" viewBox="0 0 24 24">
					<path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02z"/>
				  </svg>
				</button>
	  
				<button
				  id="fullscreen-button"
				  aria-label="Fullscreen"
				>
				  <svg fill="currentColor" viewBox="0 0 24 24">
					<path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/>
				  </svg>
				</button>
			</div>
		</div>
	</section>

		  <!-- VIDEO MODAL -->
		  <div id="video-modal" class="video-modal">
			<div class="video-modal-content">
			  <!-- Close Button -->
			  <button id="modal-close" class="modal-close" aria-label="Close modal">
				<svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
				  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
				</svg>
			  </button>
	  
			  <!-- Modal Video Player -->
			  <video
				id="modal-video-player"
				class="modal-video-player"
				controls
				autoplay
			  >
				<source id="modal-video-source" src="" type="video/mp4" />
				Your browser does not support the video tag.
			  </video>
				</div>
			</div>
		</div>

		<!-- PROCESS SECTION -->
		<section class="process-section">
			<div class="process-container">
				<!-- Header -->
				<div class="process-header">
					<h2 class="process-title">A PROCESS WAS FOUND</h2>
					<div class="process-description">
						<p>
							In the cold breathe of new year goals<span> (2023)</span><span>, </span><span class="book-text">DESIGN FOR MOTION </span><span>by </span><span class="pixel-text">Austin Shaw</span> was the first book on my read list. Learning<span> to practice free-writin</span>g,<span> where I would pour out all I understood about a subject or project. There was no prefect fit for this process than a project where I had no script, no voice over and no brief</span>.
						</p>
					</div>
				</div>

				<!-- Decorative Lines with Image Containers -->
				<div class="decorative-lines">
					<svg class="grid-lines-svg" preserveAspectRatio="none" viewBox="0 0 1512 400" xmlns="http://www.w3.org/2000/svg">
						<!-- Lines will be generated by JavaScript -->
					</svg>
					
					<!-- Image Container Overlay -->
					<div class="sketch-container-wrapper">
						<div class="sketch-container-grid">
							<!-- Main Sketch Container -->
							<div class="sketch-container main-sketch" data-grid-column="1" data-grid-row="1">
								<!-- Image will be placed here later -->
							</div>
							
							<!-- Mobile Sketch Container 1 -->
							<div class="sketch-container mobile-sketch-1" data-grid-column="2" data-grid-row="1">
								<!-- Image will be placed here later -->
							</div>
							
							<!-- Mobile Sketch Container 2 -->
							<div class="sketch-container mobile-sketch-2" data-grid-column="3" data-grid-row="1">
								<!-- Image will be placed here later -->
							</div>
						</div>
					</div>
				</div>
		</section>
	  </Layout>
	  
  <script src="https://player.vimeo.com/api/player.js"></script>
  
  <script>
	import Smooothy from 'smooothy';
	import { gsap } from 'gsap';
	import { ScrollTrigger } from 'gsap/ScrollTrigger';

	// Register GSAP plugins
	gsap.registerPlugin(ScrollTrigger);

	// GSAP Parallax Effect - Hero Content Wrapper
	const heroContentWrapper = document.querySelector('.hero-content-wrapper');
	const videoSection = document.querySelector('.video-section');
	const scrollContainer = document.querySelector('.scroll-container');

	if (heroContentWrapper && videoSection) {
		// Ease-out for fast start, slow end when scrolling back
		const easeOut = "power2.out"; // Fast start, slow end - perfect for scroll back
		
		// Calculate distance based on viewport height (since hero is 80vh)
		// Move it by 100vh to ensure it's completely out of view
		const moveDistance = -(window.innerHeight * 0.225); // Move by full viewport height
		
		console.log('Hero move distance:', moveDistance, 'vh');
		
		// Move up animation with ease-out - responsive when scrolling back
		gsap.to(heroContentWrapper, {
			y: moveDistance,
			ease: easeOut,
			scrollTrigger: {
				trigger: '.hero-section',
				start: 'top top',
				end: () => `+=${(videoSection as HTMLElement).offsetTop}`, // Completes when video section top is reached
				scrub: 0.3, // Lower value = faster response, closer to 300ms feel
				markers: false
			}
		});

		// Opacity fade with ease-out
		gsap.to(heroContentWrapper, {
			opacity: 0,
			ease: easeOut,
			scrollTrigger: {
				trigger: '.hero-section',
				start: 'center top', // Starts later - when center of hero hits top
				end: () => `+=${(videoSection as HTMLElement).offsetTop}`, // Match the movement end
				scrub: 0.3, // Match the fast response
				markers: false
			}
		});
	}

	// GSAP Snap Scrolling for Video Section
	if (scrollContainer && videoSection) {
		// Use ScrollTrigger.scrollerProxy for custom scroll container
		ScrollTrigger.scrollerProxy(scrollContainer, {
			scrollTop(value?: number) {
				if (arguments.length && value !== undefined) {
					scrollContainer.scrollTop = value;
				}
				return scrollContainer.scrollTop;
			},
			getBoundingClientRect() {
				return {
					top: 0,
					left: 0,
					width: window.innerWidth,
					height: window.innerHeight
				};
			}
		});

		// Create snap point at video section
		ScrollTrigger.create({
			trigger: '.video-section',
			scroller: scrollContainer,
			start: 'top 60%',
			end: 'top 40%',
			onEnter: () => {
				gsap.to(scrollContainer, {
					scrollTop: (videoSection as HTMLElement).offsetTop,
					duration: 0.8,
					ease: 'power2.inOut',
					overwrite: true
				});
			},
			onEnterBack: () => {
				gsap.to(scrollContainer, {
					scrollTop: (videoSection as HTMLElement).offsetTop - window.innerHeight,
					duration: 0.8,
					ease: 'power2.inOut',
					overwrite: true
				});
			},
			markers: false
		});
		
		// Refresh ScrollTrigger after setup
		ScrollTrigger.refresh();
	}

	// Initialize Smooothy Carousel
	const wrapper = document.getElementById('smoothy-carousel') as HTMLElement;
	
	if (wrapper) {
		// Get all carousel items
		const items = wrapper.querySelectorAll('.carousel-item') as NodeListOf<HTMLElement>;
		
		const carousel = new Smooothy(wrapper, {
			infinite: true,
			snap: false,
			dragSensitivity: 0.019,
			lerpFactor: 0.35,
			scrollInput: true,
			onUpdate: (core) => {
				// Apply parallax to border layer for depth effect
				items.forEach((item, index) => {
					const inner = item.querySelector('.carousel-item-inner') as HTMLElement;
					if (inner && core.parallaxValues && core.parallaxValues[index] !== undefined) {
						const parallax = core.parallaxValues[index] * 4; // Subtle parallax
						inner.style.transform = `translateX(${parallax}px)`;
					}
				});
			}
		});

		// Animation loop with auto-scroll marquee
		let autoScrollSpeed = -0.002; // Negative = scroll left, Positive = scroll right
		
		function tick() {
			// Update carousel on each frame
			carousel.update();
			
			// Auto-scroll (marquee effect)
			carousel.target += autoScrollSpeed;
			
			requestAnimationFrame(tick);
		}
		tick();

		console.log('Smooothy initialized:', carousel);

		// Lightbox functionality
		const lightboxModal = document.getElementById('lightbox-modal');
		const lightboxImage = document.getElementById('lightbox-image');
		const lightboxClose = document.getElementById('lightbox-close');
		let isDragging = false;
		let dragStartX = 0;

		// Track drag state to differentiate between click and drag
		wrapper.addEventListener('mousedown', (e) => {
			isDragging = false;
			dragStartX = e.clientX;
		});

		wrapper.addEventListener('mousemove', (e) => {
			if (Math.abs(e.clientX - dragStartX) > 5) {
				isDragging = true;
			}
		});

		// Click to open lightbox (only if not dragging)
		wrapper.addEventListener('click', (e) => {
			if (isDragging) return; // Don't open if user was dragging

			const target = e.target as HTMLElement;
			if (target) {
				const carouselInner = target.closest('.carousel-item-inner') as HTMLElement;
				if (carouselInner) {
					const imageUrl = carouselInner.getAttribute('data-image-url');
					if (imageUrl && lightboxImage && lightboxModal) {
						(lightboxImage as HTMLImageElement).src = imageUrl;
						lightboxModal.classList.add('active');
						document.body.style.overflow = 'hidden'; // Prevent background scroll
					}
				}
			}
		});

		// Close lightbox
		if (lightboxClose && lightboxModal) {
			lightboxClose.addEventListener('click', (e) => {
				e.stopPropagation(); // Prevent event from bubbling
				lightboxModal.classList.remove('active');
				document.body.style.overflow = ''; // Restore scroll
			});

			// Close on background click
			lightboxModal.addEventListener('click', (e) => {
				if (e.target === lightboxModal) {
					lightboxModal.classList.remove('active');
					document.body.style.overflow = '';
				}
			});

			// Close on Escape key
			document.addEventListener('keydown', (e) => {
				if (e.key === 'Escape' && lightboxModal.classList.contains('active')) {
					lightboxModal.classList.remove('active');
					document.body.style.overflow = '';
				}
			});
		}
	} else {
		console.error('Carousel wrapper not found');
	}

		// Video Player Controls with Vimeo
		const videoIframe = document.getElementById('video-player') as HTMLIFrameElement;
		const playButton = document.getElementById('play-button');
		const pauseButton = document.getElementById('pause-button');
		const muteButton = document.getElementById('mute-button');
		const fullscreenButton = document.getElementById('fullscreen-button');
		const progressBar = document.getElementById('progress-bar') as HTMLInputElement;
		const currentTimeDisplay = document.getElementById('current-time');
		const durationDisplay = document.getElementById('duration');
		const videoOverlay = document.getElementById('video-overlay');
		const videoControls = document.getElementById('video-controls');
	  
		let isPlaying = false;
		let player: any = null;
		
		// Wait for Vimeo API to load and initialize player
		function initVimeoPlayer() {
			if (videoIframe && typeof (window as any).Vimeo !== 'undefined') {
				player = new (window as any).Vimeo.Player(videoIframe);
				
				console.log('Vimeo Player initialized:', player);
				
				// Get and display duration
				player.getDuration().then((duration: number) => {
					if (durationDisplay) {
						durationDisplay.textContent = formatTime(duration);
					}
				}).catch((error: any) => {
					console.error('Error getting duration:', error);
				});
				
				// Update progress as video plays
				player.on('timeupdate', (data: any) => {
					if (progressBar && currentTimeDisplay) {
						const percent = (data.seconds / data.duration) * 100;
						progressBar.value = percent.toString();
						currentTimeDisplay.textContent = formatTime(data.seconds);
					}
				});
				
				// Listen for play event
				player.on('play', () => {
					console.log('Video started playing');
					isPlaying = true;
				});
				
				// Listen for pause event
				player.on('pause', () => {
					console.log('Video paused');
					isPlaying = false;
				});
			} else {
				console.error('Vimeo Player API not loaded or iframe not found');
				// Retry after a short delay
				setTimeout(initVimeoPlayer, 500);
			}
		}
		
		// Initialize when DOM is ready
		if (document.readyState === 'loading') {
			document.addEventListener('DOMContentLoaded', initVimeoPlayer);
		} else {
			initVimeoPlayer();
		}
	  
		// Format time helper
		function formatTime(seconds: number): string {
		  const mins = Math.floor(seconds / 60);
		  const secs = Math.floor(seconds % 60);
		  return `${mins}:${secs.toString().padStart(2, '0')}`;
		}
	  
		// Play video
		function playVideo() {
		  console.log('Play button clicked, player:', player);
		  if (player) {
			player.play().then(() => {
			  console.log('Video playing successfully');
			  isPlaying = true;
			  if (playButton) playButton.style.opacity = '0';
			  if (playButton) playButton.style.pointerEvents = 'none';
			  if (videoOverlay) videoOverlay.style.opacity = '0';
			  if (videoControls) videoControls.style.opacity = '1';
			}).catch((error: any) => {
			  console.error('Error playing video:', error);
			});
		  } else {
			console.error('Player not initialized yet');
		  }
		}
	  
		// Pause video
		function pauseVideo() {
		  if (player) {
			player.pause();
			isPlaying = false;
		  }
		  if (playButton) playButton.style.opacity = '1';
		  if (playButton) playButton.style.pointerEvents = 'auto';
		  if (videoOverlay) videoOverlay.style.opacity = '1';
		}
	  
		// Toggle mute
		function toggleMute() {
		  if (player && muteButton) {
			player.getVolume().then((volume: number) => {
			  if (volume > 0) {
				player.setVolume(0);
				muteButton.innerHTML = '<svg fill="currentColor" viewBox="0 0 24 24"><path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z"/></svg>';
			  } else {
				player.setVolume(1);
				muteButton.innerHTML = '<svg fill="currentColor" viewBox="0 0 24 24"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02z"/></svg>';
			  }
			});
		  }
		}
	  
		// Toggle fullscreen
		function toggleFullscreen() {
		  const videoSection = document.querySelector('.video-section');
		  if (!document.fullscreenElement) {
			videoSection?.requestFullscreen();
		  } else {
			document.exitFullscreen();
		  }
		}
	  
		// Seek video
		function seekVideo(e: Event) {
		  if (player && progressBar) {
			const target = e.target as HTMLInputElement;
			const percent = parseFloat(target.value);
			player.getDuration().then((duration: number) => {
			  const time = (percent / 100) * duration;
			  player.setCurrentTime(time);
						});
					}
				}
	  
		// Event listeners
		playButton?.addEventListener('click', playVideo);
		pauseButton?.addEventListener('click', pauseVideo);
		muteButton?.addEventListener('click', toggleMute);
		fullscreenButton?.addEventListener('click', toggleFullscreen);
		progressBar?.addEventListener('input', seekVideo);
		
		// Video ended - listen to Vimeo player events
		if (player) {
			player.on('ended', () => {
				pauseVideo();
				if (progressBar) progressBar.value = '0';
			});
		}
	  
		// Show/hide controls on hover when playing
		videoSection?.addEventListener('mouseenter', () => {
		  if (isPlaying && videoControls) {
			videoControls.style.opacity = '1';
		  }
		});
	  
		let hideControlsTimeout: any;
		videoSection?.addEventListener('mousemove', () => {
		  if (isPlaying && videoControls) {
			videoControls.style.opacity = '1';
			clearTimeout(hideControlsTimeout);
			hideControlsTimeout = setTimeout(() => {
			  if (videoControls) videoControls.style.opacity = '0.3';
			}, 2000);
		  }
		});
	  
		videoSection?.addEventListener('mouseleave', () => {
		  if (isPlaying && videoControls) {
			videoControls.style.opacity = '0.3';
		  }
		});
	  
		// Pause video when section goes out of view
		if (videoSection && player) {
		  const observer = new IntersectionObserver(
			(entries) => {
			  entries.forEach((entry) => {
				// If video section is not intersecting (out of view) and video is playing, pause it
				if (!entry.isIntersecting && isPlaying) {
				  pauseVideo();
				}
			  });
			},
			{
			  threshold: 0.5, // Trigger when 50% of the section is out of view
			  root: null, // Use viewport as root
			}
		  );
	  
		  observer.observe(videoSection);
		}
	  
		// Gallery Modal Functionality
		const modal = document.getElementById('video-modal');
		const modalVideo = document.getElementById('modal-video-player') as HTMLVideoElement;
		const modalVideoSource = document.getElementById('modal-video-source') as HTMLSourceElement;
		const modalClose = document.getElementById('modal-close');
		const galleryItems = document.querySelectorAll('.gallery-item');
	  
		// Open modal with video
		function openModal(videoUrl: string) {
		  if (modal && modalVideo && modalVideoSource) {
			modalVideoSource.src = videoUrl;
			modalVideo.load();
			modal.classList.add('active');
			document.body.style.overflow = 'hidden'; // Prevent background scrolling
			
			// Pause main video if playing
			if (isPlaying) {
			  pauseVideo();
			}
		  }
		}
	  
		// Close modal
		function closeModal() {
		  if (modal && modalVideo) {
			modal.classList.remove('active');
			modalVideo.pause();
			modalVideo.currentTime = 0;
			document.body.style.overflow = ''; // Re-enable scrolling
		  }
		}
	  
		// Add click handlers to gallery items
		galleryItems.forEach((item) => {
		  item.addEventListener('click', () => {
			const videoUrl = item.getAttribute('data-video');
			if (videoUrl) {
			  openModal(videoUrl);
			}
		  });
		});
	  
		// Close modal on close button click
		modalClose?.addEventListener('click', closeModal);
	  
		// Close modal on outside click
		modal?.addEventListener('click', (e) => {
		  if (e.target === modal) {
			closeModal();
		  }
		});
	  
		// Close modal on Escape key
		document.addEventListener('keydown', (e) => {
		  if (e.key === 'Escape' && modal?.classList.contains('active')) {
			closeModal();
		  }
		});
	  
		// Pause marquee on hover
		const marqueeContent = document.querySelector('.marquee-content') as HTMLElement;
		const marqueeContainer = document.querySelector('.marquee-container');
	  
		marqueeContainer?.addEventListener('mouseenter', () => {
		  if (marqueeContent) {
			marqueeContent.style.animationPlayState = 'paused';
		  }
		});
	  
		marqueeContainer?.addEventListener('mouseleave', () => {
		  if (marqueeContent) {
			marqueeContent.style.animationPlayState = 'running';
		  }
	});

		// SVG Grid Lines Generator
		function generateGridLines() {
			const svg = document.querySelector('.grid-lines-svg') as SVGElement;
			if (!svg) return;

			const container = svg.parentElement;
			if (!container) return;

			// Configuration
			const config = {
				lineSpacing: 22, // Spacing between lines in pixels
				topSegmentStart: 0.24, // 333.508 / 1395 ≈ 0.24
				topSegmentEnd: 0.434, // 605.368 / 1395 ≈ 0.434
				middleSegmentEnd: 0.706, // 985.368 / 1395 ≈ 0.706
				bottomSegmentEnd: 0.901, // 1257.23 / 1395 ≈ 0.901
				thickStrokeWidth: 9,
				thinStrokeWidth: 1,
				strokeColor: '#ACAAA3',
				startOffset: 5 // Minimal offset to prevent cut-off
			};

			// Clear existing lines
			svg.innerHTML = '';

			// Calculate container width and number of lines
			const containerWidth = container.offsetWidth;
			
			// Use full container width for viewBox
			svg.setAttribute('viewBox', `0 0 ${containerWidth} 400`);
			
			// Calculate available width for lines (account for left/right padding of overlay grid)
			let horizontalPadding = 0;
			const overlayGridForPadding = container.querySelector('.sketch-container-grid') as HTMLElement | null;
			if (overlayGridForPadding) {
				const cs2 = getComputedStyle(overlayGridForPadding);
				const padLeft = parseFloat(cs2.paddingLeft || '0');
				const padRight = parseFloat(cs2.paddingRight || '0');
				horizontalPadding = padLeft + padRight;
			}
			const availableWidth = containerWidth - horizontalPadding - (config.startOffset * 2);
			
			// Keep constant spacing but distribute leftover equally on both sides
			const spacing = config.lineSpacing;
			const numLines = Math.floor(availableWidth / spacing) + 1; // number of lines so last index fits in width
			const spanWidth = (numLines - 1) * spacing; // distance from first to last line
			const sideRemainder = Math.max(availableWidth - spanWidth, 0);
			const sidePadding = sideRemainder / 2; // equal gap on left and right inside overlay padding
			
			// Start position: left overlay padding + inner offset + equalized side padding
			const leftOverlayPadding = overlayGridForPadding ? parseFloat(getComputedStyle(overlayGridForPadding).paddingLeft || '0') : 0;
			const adjustedStartOffset = leftOverlayPadding + config.startOffset + sidePadding;

			// Get the actual SVG height from viewBox or container
			const svgHeight = (svg as any).viewBox.baseVal.height || 400;

			// Read top/bottom padding from the overlay grid so thick segments can form a border
			let topPaddingPx = 0;
			let bottomPaddingPx = 0;
			const overlayGrid = container.querySelector('.sketch-container-grid') as HTMLElement | null;
			if (overlayGrid) {
				const cs = getComputedStyle(overlayGrid);
				topPaddingPx = parseFloat(cs.paddingTop || '0');
				bottomPaddingPx = parseFloat(cs.paddingBottom || '0');
			}

			// Generate lines
			for (let i = 0; i < numLines; i++) {
				const x = adjustedStartOffset + (i * spacing);
				const groupIndex = Math.floor(i / 5); // Group every 5 lines for future animation
				
				// Create group for this line (for future animation control)
				const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
				group.classList.add('grid-line-group');
				group.setAttribute('data-group', groupIndex.toString());
				group.setAttribute('data-line', i.toString());

				// Top segment (thick stroke) - from very top to the start of the middle (acts like border)
				const topLine = document.createElementNS('http://www.w3.org/2000/svg', 'path');
				topLine.setAttribute('d', `M${x} ${topPaddingPx}V0`);
				topLine.setAttribute('stroke', config.strokeColor);
				topLine.setAttribute('stroke-width', config.thickStrokeWidth.toString());
				topLine.classList.add('grid-line-top');
				group.appendChild(topLine);

				// Middle segment (thin stroke) - spans the grid area between paddings
				const middleLine = document.createElementNS('http://www.w3.org/2000/svg', 'path');
				middleLine.setAttribute('d', `M${x} ${topPaddingPx}V${svgHeight - bottomPaddingPx}`);
				middleLine.setAttribute('stroke', config.strokeColor);
				middleLine.setAttribute('stroke-width', config.thinStrokeWidth.toString());
				middleLine.classList.add('grid-line-middle');
				group.appendChild(middleLine);

				// Bottom segment (thick stroke) - from end of middle to very bottom (acts like border)
				const bottomLine = document.createElementNS('http://www.w3.org/2000/svg', 'path');
				bottomLine.setAttribute('d', `M${x} ${svgHeight}V${svgHeight - bottomPaddingPx}`);
				bottomLine.setAttribute('stroke', config.strokeColor);
				bottomLine.setAttribute('stroke-width', config.thickStrokeWidth.toString());
				bottomLine.classList.add('grid-line-bottom');
				group.appendChild(bottomLine);

				svg.appendChild(group);
			}
		}

		// Update SVG height based on container grid height
		function updateSVGHeight() {
			const svg = document.querySelector('.grid-lines-svg') as SVGElement;
			const containerWrapper = document.querySelector('.sketch-container-wrapper') as HTMLElement;
			const decorativeLines = document.querySelector('.decorative-lines') as HTMLElement;
			
			if (!svg || !containerWrapper || !decorativeLines) return;
			
			// Get the actual height of the container wrapper
			const gridHeight = containerWrapper.offsetHeight;
			
			// Update decorative-lines container height
			decorativeLines.style.height = `${gridHeight}px`;
			
			// Get current viewBox
			const viewBox = svg.getAttribute('viewBox');
			if (!viewBox) return;
			
			const [x, y, width] = viewBox.split(' ').map(Number);
			
			// Update viewBox height to match grid height
			svg.setAttribute('viewBox', `${x} ${y} ${width} ${gridHeight}`);
			
			// Regenerate lines with new height
			generateGridLines();
		}

		// Call after grid generation and on resize
		window.addEventListener('DOMContentLoaded', () => {
			setTimeout(() => {
				generateGridLines();
				updateSVGHeight();
			}, 100);
		});

		// Also try to initialize immediately if DOM is already loaded
		if (document.readyState === 'loading') {
			document.addEventListener('DOMContentLoaded', () => {
				setTimeout(() => {
					generateGridLines();
					updateSVGHeight();
				}, 100);
			});
		} else {
			setTimeout(() => {
				generateGridLines();
				updateSVGHeight();
			}, 100);
		}

		// Update on resize
		let resizeTimeout: ReturnType<typeof setTimeout>;
		window.addEventListener('resize', () => {
			clearTimeout(resizeTimeout);
			resizeTimeout = setTimeout(() => {
				updateSVGHeight();
			}, 250);
		});
</script>